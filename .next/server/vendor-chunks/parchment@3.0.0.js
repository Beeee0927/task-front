"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parchment@3.0.0";
exports.ids = ["vendor-chunks/parchment@3.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/parchment@3.0.0/node_modules/parchment/dist/parchment.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/parchment@3.0.0/node_modules/parchment/dist/parchment.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attributor: () => (/* binding */ Attributor),\n/* harmony export */   AttributorStore: () => (/* binding */ AttributorStore$1),\n/* harmony export */   BlockBlot: () => (/* binding */ BlockBlot$1),\n/* harmony export */   ClassAttributor: () => (/* binding */ ClassAttributor$1),\n/* harmony export */   ContainerBlot: () => (/* binding */ ContainerBlot$1),\n/* harmony export */   EmbedBlot: () => (/* binding */ EmbedBlot$1),\n/* harmony export */   InlineBlot: () => (/* binding */ InlineBlot$1),\n/* harmony export */   LeafBlot: () => (/* binding */ LeafBlot$1),\n/* harmony export */   ParentBlot: () => (/* binding */ ParentBlot$1),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   Scope: () => (/* binding */ Scope),\n/* harmony export */   ScrollBlot: () => (/* binding */ ScrollBlot$1),\n/* harmony export */   StyleAttributor: () => (/* binding */ StyleAttributor$1),\n/* harmony export */   TextBlot: () => (/* binding */ TextBlot$1)\n/* harmony export */ });\nvar Scope = /* @__PURE__ */ ((Scope2) => (Scope2[Scope2.TYPE = 3] = \"TYPE\", Scope2[Scope2.LEVEL = 12] = \"LEVEL\", Scope2[Scope2.ATTRIBUTE = 13] = \"ATTRIBUTE\", Scope2[Scope2.BLOT = 14] = \"BLOT\", Scope2[Scope2.INLINE = 7] = \"INLINE\", Scope2[Scope2.BLOCK = 11] = \"BLOCK\", Scope2[Scope2.BLOCK_BLOT = 10] = \"BLOCK_BLOT\", Scope2[Scope2.INLINE_BLOT = 6] = \"INLINE_BLOT\", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = \"BLOCK_ATTRIBUTE\", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = \"INLINE_ATTRIBUTE\", Scope2[Scope2.ANY = 15] = \"ANY\", Scope2))(Scope || {});\nclass Attributor {\n  constructor(attrName, keyName, options = {}) {\n    this.attrName = attrName, this.keyName = keyName;\n    const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;\n    this.scope = options.scope != null ? (\n      // Ignore type bits, force attribute bit\n      options.scope & Scope.LEVEL | attributeBit\n    ) : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);\n  }\n  static keys(node) {\n    return Array.from(node.attributes).map((item) => item.name);\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.setAttribute(this.keyName, value), !0) : !1;\n  }\n  canAdd(_node, value) {\n    return this.whitelist == null ? !0 : typeof value == \"string\" ? this.whitelist.indexOf(value.replace(/[\"']/g, \"\")) > -1 : this.whitelist.indexOf(value) > -1;\n  }\n  remove(node) {\n    node.removeAttribute(this.keyName);\n  }\n  value(node) {\n    const value = node.getAttribute(this.keyName);\n    return this.canAdd(node, value) && value ? value : \"\";\n  }\n}\nclass ParchmentError extends Error {\n  constructor(message) {\n    message = \"[Parchment] \" + message, super(message), this.message = message, this.name = this.constructor.name;\n  }\n}\nconst _Registry = class _Registry {\n  constructor() {\n    this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};\n  }\n  static find(node, bubble = !1) {\n    if (node == null)\n      return null;\n    if (this.blots.has(node))\n      return this.blots.get(node) || null;\n    if (bubble) {\n      let parentNode = null;\n      try {\n        parentNode = node.parentNode;\n      } catch {\n        return null;\n      }\n      return this.find(parentNode, bubble);\n    }\n    return null;\n  }\n  create(scroll, input, value) {\n    const match2 = this.query(input);\n    if (match2 == null)\n      throw new ParchmentError(`Unable to create ${input} blot`);\n    const blotClass = match2, node = (\n      // @ts-expect-error Fix me later\n      input instanceof Node || input.nodeType === Node.TEXT_NODE ? input : blotClass.create(value)\n    ), blot = new blotClass(scroll, node, value);\n    return _Registry.blots.set(blot.domNode, blot), blot;\n  }\n  find(node, bubble = !1) {\n    return _Registry.find(node, bubble);\n  }\n  query(query, scope = Scope.ANY) {\n    let match2;\n    return typeof query == \"string\" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == \"number\" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute(\"class\") || \"\").split(/\\s+/).some((name) => (match2 = this.classes[name], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : \"scope\" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;\n  }\n  register(...definitions) {\n    return definitions.map((definition) => {\n      const isBlot = \"blotName\" in definition, isAttr = \"attrName\" in definition;\n      if (!isBlot && !isAttr)\n        throw new ParchmentError(\"Invalid definition\");\n      if (isBlot && definition.blotName === \"abstract\")\n        throw new ParchmentError(\"Cannot register abstract class\");\n      const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;\n      return this.types[key] = definition, isAttr ? typeof definition.keyName == \"string\" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map((tagName) => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach((tag) => {\n        (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);\n      }))), definition;\n    });\n  }\n};\n_Registry.blots = /* @__PURE__ */ new WeakMap();\nlet Registry = _Registry;\nfunction match(node, prefix) {\n  return (node.getAttribute(\"class\") || \"\").split(/\\s+/).filter((name) => name.indexOf(`${prefix}-`) === 0);\n}\nclass ClassAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"class\") || \"\").split(/\\s+/).map((name) => name.split(\"-\").slice(0, -1).join(\"-\"));\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (this.remove(node), node.classList.add(`${this.keyName}-${value}`), !0) : !1;\n  }\n  remove(node) {\n    match(node, this.keyName).forEach((name) => {\n      node.classList.remove(name);\n    }), node.classList.length === 0 && node.removeAttribute(\"class\");\n  }\n  value(node) {\n    const value = (match(node, this.keyName)[0] || \"\").slice(this.keyName.length + 1);\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst ClassAttributor$1 = ClassAttributor;\nfunction camelize(name) {\n  const parts = name.split(\"-\"), rest = parts.slice(1).map((part) => part[0].toUpperCase() + part.slice(1)).join(\"\");\n  return parts[0] + rest;\n}\nclass StyleAttributor extends Attributor {\n  static keys(node) {\n    return (node.getAttribute(\"style\") || \"\").split(\";\").map((value) => value.split(\":\")[0].trim());\n  }\n  add(node, value) {\n    return this.canAdd(node, value) ? (node.style[camelize(this.keyName)] = value, !0) : !1;\n  }\n  remove(node) {\n    node.style[camelize(this.keyName)] = \"\", node.getAttribute(\"style\") || node.removeAttribute(\"style\");\n  }\n  value(node) {\n    const value = node.style[camelize(this.keyName)];\n    return this.canAdd(node, value) ? value : \"\";\n  }\n}\nconst StyleAttributor$1 = StyleAttributor;\nclass AttributorStore {\n  constructor(domNode) {\n    this.attributes = {}, this.domNode = domNode, this.build();\n  }\n  attribute(attribute, value) {\n    value ? attribute.add(this.domNode, value) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);\n  }\n  build() {\n    this.attributes = {};\n    const blot = Registry.find(this.domNode);\n    if (blot == null)\n      return;\n    const attributes = Attributor.keys(this.domNode), classes = ClassAttributor$1.keys(this.domNode), styles = StyleAttributor$1.keys(this.domNode);\n    attributes.concat(classes).concat(styles).forEach((name) => {\n      const attr = blot.scroll.query(name, Scope.ATTRIBUTE);\n      attr instanceof Attributor && (this.attributes[attr.attrName] = attr);\n    });\n  }\n  copy(target) {\n    Object.keys(this.attributes).forEach((key) => {\n      const value = this.attributes[key].value(this.domNode);\n      target.format(key, value);\n    });\n  }\n  move(target) {\n    this.copy(target), Object.keys(this.attributes).forEach((key) => {\n      this.attributes[key].remove(this.domNode);\n    }), this.attributes = {};\n  }\n  values() {\n    return Object.keys(this.attributes).reduce(\n      (attributes, name) => (attributes[name] = this.attributes[name].value(this.domNode), attributes),\n      {}\n    );\n  }\n}\nconst AttributorStore$1 = AttributorStore, _ShadowBlot = class _ShadowBlot {\n  constructor(scroll, domNode) {\n    this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;\n  }\n  static create(rawValue) {\n    if (this.tagName == null)\n      throw new ParchmentError(\"Blot definition missing tagName\");\n    let node, value;\n    return Array.isArray(this.tagName) ? (typeof rawValue == \"string\" ? (value = rawValue.toUpperCase(), parseInt(value, 10).toString() === value && (value = parseInt(value, 10))) : typeof rawValue == \"number\" && (value = rawValue), typeof value == \"number\" ? node = document.createElement(this.tagName[value - 1]) : value && this.tagName.indexOf(value) > -1 ? node = document.createElement(value) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;\n  }\n  // Hack for accessing inherited static methods\n  get statics() {\n    return this.constructor;\n  }\n  attach() {\n  }\n  clone() {\n    const domNode = this.domNode.cloneNode(!1);\n    return this.scroll.create(domNode);\n  }\n  detach() {\n    this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);\n  }\n  deleteAt(index, length) {\n    this.isolate(index, length).remove();\n  }\n  formatAt(index, length, name, value) {\n    const blot = this.isolate(index, length);\n    if (this.scroll.query(name, Scope.BLOT) != null && value)\n      blot.wrap(name, value);\n    else if (this.scroll.query(name, Scope.ATTRIBUTE) != null) {\n      const parent = this.scroll.create(this.statics.scope);\n      blot.wrap(parent), parent.format(name, value);\n    }\n  }\n  insertAt(index, value, def) {\n    const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def), ref = this.split(index);\n    this.parent.insertBefore(blot, ref || void 0);\n  }\n  isolate(index, length) {\n    const target = this.split(index);\n    if (target == null)\n      throw new Error(\"Attempt to isolate at end\");\n    return target.split(length), target;\n  }\n  length() {\n    return 1;\n  }\n  offset(root = this.parent) {\n    return this.parent == null || this === root ? 0 : this.parent.children.offset(this) + this.parent.offset(root);\n  }\n  optimize(_context) {\n    this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);\n  }\n  remove() {\n    this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();\n  }\n  replaceWith(name, value) {\n    const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;\n  }\n  split(index, _force) {\n    return index === 0 ? this : this.next;\n  }\n  update(_mutations, _context) {\n  }\n  wrap(name, value) {\n    const wrapper = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != \"function\")\n      throw new ParchmentError(`Cannot wrap ${name}`);\n    return wrapper.appendChild(this), wrapper;\n  }\n};\n_ShadowBlot.blotName = \"abstract\";\nlet ShadowBlot = _ShadowBlot;\nconst _LeafBlot = class _LeafBlot extends ShadowBlot {\n  /**\n   * Returns the value represented by domNode if it is this Blot's type\n   * No checking that domNode can represent this Blot type is required so\n   * applications needing it should check externally before calling.\n   */\n  static value(_domNode) {\n    return !0;\n  }\n  /**\n   * Given location represented by node and offset from DOM Selection Range,\n   * return index to that location.\n   */\n  index(node, offset) {\n    return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;\n  }\n  /**\n   * Given index to location within blot, return node and offset representing\n   * that location, consumable by DOM Selection Range\n   */\n  position(index, _inclusive) {\n    let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);\n    return index > 0 && (offset += 1), [this.parent.domNode, offset];\n  }\n  /**\n   * Return value represented by this blot\n   * Should not change without interaction from API or\n   * user change detectable by update()\n   */\n  value() {\n    return {\n      [this.statics.blotName]: this.statics.value(this.domNode) || !0\n    };\n  }\n};\n_LeafBlot.scope = Scope.INLINE_BLOT;\nlet LeafBlot = _LeafBlot;\nconst LeafBlot$1 = LeafBlot;\nclass LinkedList {\n  constructor() {\n    this.head = null, this.tail = null, this.length = 0;\n  }\n  append(...nodes) {\n    if (this.insertBefore(nodes[0], null), nodes.length > 1) {\n      const rest = nodes.slice(1);\n      this.append(...rest);\n    }\n  }\n  at(index) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur && index > 0; )\n      index -= 1, cur = next();\n    return cur;\n  }\n  contains(node) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; ) {\n      if (cur === node)\n        return !0;\n      cur = next();\n    }\n    return !1;\n  }\n  indexOf(node) {\n    const next = this.iterator();\n    let cur = next(), index = 0;\n    for (; cur; ) {\n      if (cur === node)\n        return index;\n      index += 1, cur = next();\n    }\n    return -1;\n  }\n  insertBefore(node, refNode) {\n    node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);\n  }\n  offset(target) {\n    let index = 0, cur = this.head;\n    for (; cur != null; ) {\n      if (cur === target)\n        return index;\n      index += cur.length(), cur = cur.next;\n    }\n    return -1;\n  }\n  remove(node) {\n    this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);\n  }\n  iterator(curNode = this.head) {\n    return () => {\n      const ret = curNode;\n      return curNode != null && (curNode = curNode.next), ret;\n    };\n  }\n  find(index, inclusive = !1) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; ) {\n      const length = cur.length();\n      if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0))\n        return [cur, index];\n      index -= length, cur = next();\n    }\n    return [null, 0];\n  }\n  forEach(callback) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; )\n      callback(cur), cur = next();\n  }\n  forEachAt(index, length, callback) {\n    if (length <= 0)\n      return;\n    const [startNode, offset] = this.find(index);\n    let curIndex = index - offset;\n    const next = this.iterator(startNode);\n    let cur = next();\n    for (; cur && curIndex < index + length; ) {\n      const curLength = cur.length();\n      index > curIndex ? callback(\n        cur,\n        index - curIndex,\n        Math.min(length, curIndex + curLength - index)\n      ) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();\n    }\n  }\n  map(callback) {\n    return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);\n  }\n  reduce(callback, memo) {\n    const next = this.iterator();\n    let cur = next();\n    for (; cur; )\n      memo = callback(memo, cur), cur = next();\n    return memo;\n  }\n}\nfunction makeAttachedBlot(node, scroll) {\n  const found = scroll.find(node);\n  if (found)\n    return found;\n  try {\n    return scroll.create(node);\n  } catch {\n    const blot = scroll.create(Scope.INLINE);\n    return Array.from(node.childNodes).forEach((child) => {\n      blot.domNode.appendChild(child);\n    }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;\n  }\n}\nconst _ParentBlot = class _ParentBlot extends ShadowBlot {\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.uiNode = null, this.build();\n  }\n  appendChild(other) {\n    this.insertBefore(other);\n  }\n  attach() {\n    super.attach(), this.children.forEach((child) => {\n      child.attach();\n    });\n  }\n  attachUI(node) {\n    this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot.uiClass && this.uiNode.classList.add(_ParentBlot.uiClass), this.uiNode.setAttribute(\"contenteditable\", \"false\"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);\n  }\n  /**\n   * Called during construction, should fill its own children LinkedList.\n   */\n  build() {\n    this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode).reverse().forEach((node) => {\n      try {\n        const child = makeAttachedBlot(node, this.scroll);\n        this.insertBefore(child, this.children.head || void 0);\n      } catch (err) {\n        if (err instanceof ParchmentError)\n          return;\n        throw err;\n      }\n    });\n  }\n  deleteAt(index, length) {\n    if (index === 0 && length === this.length())\n      return this.remove();\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.deleteAt(offset, childLength);\n    });\n  }\n  descendant(criteria, index = 0) {\n    const [child, offset] = this.children.find(index);\n    return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot ? child.descendant(criteria, offset) : [null, -1];\n  }\n  descendants(criteria, index = 0, length = Number.MAX_VALUE) {\n    let descendants = [], lengthLeft = length;\n    return this.children.forEachAt(\n      index,\n      length,\n      (child, childIndex, childLength) => {\n        (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot && (descendants = descendants.concat(\n          child.descendants(criteria, childIndex, lengthLeft)\n        )), lengthLeft -= childLength;\n      }\n    ), descendants;\n  }\n  detach() {\n    this.children.forEach((child) => {\n      child.detach();\n    }), super.detach();\n  }\n  enforceAllowedChildren() {\n    let done = !1;\n    this.children.forEach((child) => {\n      done || this.statics.allowedChildren.some(\n        (def) => child instanceof def\n      ) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = !0) : child instanceof _ParentBlot ? child.unwrap() : child.remove());\n    });\n  }\n  formatAt(index, length, name, value) {\n    this.children.forEachAt(index, length, (child, offset, childLength) => {\n      child.formatAt(offset, childLength, name, value);\n    });\n  }\n  insertAt(index, value, def) {\n    const [child, offset] = this.children.find(index);\n    if (child)\n      child.insertAt(offset, value, def);\n    else {\n      const blot = def == null ? this.scroll.create(\"text\", value) : this.scroll.create(value, def);\n      this.appendChild(blot);\n    }\n  }\n  insertBefore(childBlot, refBlot) {\n    childBlot.parent != null && childBlot.parent.children.remove(childBlot);\n    let refDomNode = null;\n    this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();\n  }\n  length() {\n    return this.children.reduce((memo, child) => memo + child.length(), 0);\n  }\n  moveChildren(targetParent, refNode) {\n    this.children.forEach((child) => {\n      targetParent.insertBefore(child, refNode);\n    });\n  }\n  optimize(context) {\n    if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0)\n      if (this.statics.defaultChild != null) {\n        const child = this.scroll.create(this.statics.defaultChild.blotName);\n        this.appendChild(child);\n      } else\n        this.remove();\n  }\n  path(index, inclusive = !1) {\n    const [child, offset] = this.children.find(index, inclusive), position = [[this, index]];\n    return child instanceof _ParentBlot ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);\n  }\n  removeChild(child) {\n    this.children.remove(child);\n  }\n  replaceWith(name, value) {\n    const replacement = typeof name == \"string\" ? this.scroll.create(name, value) : name;\n    return replacement instanceof _ParentBlot && this.moveChildren(replacement), super.replaceWith(replacement);\n  }\n  split(index, force = !1) {\n    if (!force) {\n      if (index === 0)\n        return this;\n      if (index === this.length())\n        return this.next;\n    }\n    const after = this.clone();\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), (child, offset, _length) => {\n      const split = child.split(offset, force);\n      split != null && after.appendChild(split);\n    }), after;\n  }\n  splitAfter(child) {\n    const after = this.clone();\n    for (; child.next != null; )\n      after.appendChild(child.next);\n    return this.parent && this.parent.insertBefore(after, this.next || void 0), after;\n  }\n  unwrap() {\n    this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();\n  }\n  update(mutations, _context) {\n    const addedNodes = [], removedNodes = [];\n    mutations.forEach((mutation) => {\n      mutation.target === this.domNode && mutation.type === \"childList\" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));\n    }), removedNodes.forEach((node) => {\n      if (node.parentNode != null && // @ts-expect-error Fix me later\n      node.tagName !== \"IFRAME\" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY)\n        return;\n      const blot = this.scroll.find(node);\n      blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();\n    }), addedNodes.filter((node) => node.parentNode === this.domNode && node !== this.uiNode).sort((a, b) => a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((node) => {\n      let refBlot = null;\n      node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));\n      const blot = makeAttachedBlot(node, this.scroll);\n      (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));\n    }), this.enforceAllowedChildren();\n  }\n};\n_ParentBlot.uiClass = \"\";\nlet ParentBlot = _ParentBlot;\nconst ParentBlot$1 = ParentBlot;\nfunction isEqual(obj1, obj2) {\n  if (Object.keys(obj1).length !== Object.keys(obj2).length)\n    return !1;\n  for (const prop in obj1)\n    if (obj1[prop] !== obj2[prop])\n      return !1;\n  return !0;\n}\nconst _InlineBlot = class _InlineBlot extends ParentBlot$1 {\n  static create(value) {\n    return super.create(value);\n  }\n  static formats(domNode, scroll) {\n    const match2 = scroll.query(_InlineBlot.blotName);\n    if (!(match2 != null && domNode.tagName === match2.tagName)) {\n      if (typeof this.tagName == \"string\")\n        return !0;\n      if (Array.isArray(this.tagName))\n        return domNode.tagName.toLowerCase();\n    }\n  }\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n  }\n  format(name, value) {\n    if (name === this.statics.blotName && !value)\n      this.children.forEach((child) => {\n        child instanceof _InlineBlot || (child = child.wrap(_InlineBlot.blotName, !0)), this.attributes.copy(child);\n      }), this.unwrap();\n    else {\n      const format = this.scroll.query(name, Scope.INLINE);\n      if (format == null)\n        return;\n      format instanceof Attributor ? this.attributes.attribute(format, value) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value);\n    }\n  }\n  formats() {\n    const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);\n    return format != null && (formats[this.statics.blotName] = format), formats;\n  }\n  formatAt(index, length, name, value) {\n    this.formats()[name] != null || this.scroll.query(name, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name, value) : super.formatAt(index, length, name, value);\n  }\n  optimize(context) {\n    super.optimize(context);\n    const formats = this.formats();\n    if (Object.keys(formats).length === 0)\n      return this.unwrap();\n    const next = this.next;\n    next instanceof _InlineBlot && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), next.remove());\n  }\n  replaceWith(name, value) {\n    const replacement = super.replaceWith(name, value);\n    return this.attributes.copy(replacement), replacement;\n  }\n  update(mutations, context) {\n    super.update(mutations, context), mutations.some(\n      (mutation) => mutation.target === this.domNode && mutation.type === \"attributes\"\n    ) && this.attributes.build();\n  }\n  wrap(name, value) {\n    const wrapper = super.wrap(name, value);\n    return wrapper instanceof _InlineBlot && this.attributes.move(wrapper), wrapper;\n  }\n};\n_InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = \"inline\", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = \"SPAN\";\nlet InlineBlot = _InlineBlot;\nconst InlineBlot$1 = InlineBlot, _BlockBlot = class _BlockBlot extends ParentBlot$1 {\n  static create(value) {\n    return super.create(value);\n  }\n  static formats(domNode, scroll) {\n    const match2 = scroll.query(_BlockBlot.blotName);\n    if (!(match2 != null && domNode.tagName === match2.tagName)) {\n      if (typeof this.tagName == \"string\")\n        return !0;\n      if (Array.isArray(this.tagName))\n        return domNode.tagName.toLowerCase();\n    }\n  }\n  constructor(scroll, domNode) {\n    super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);\n  }\n  format(name, value) {\n    const format = this.scroll.query(name, Scope.BLOCK);\n    format != null && (format instanceof Attributor ? this.attributes.attribute(format, value) : name === this.statics.blotName && !value ? this.replaceWith(_BlockBlot.blotName) : value && (name !== this.statics.blotName || this.formats()[name] !== value) && this.replaceWith(name, value));\n  }\n  formats() {\n    const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);\n    return format != null && (formats[this.statics.blotName] = format), formats;\n  }\n  formatAt(index, length, name, value) {\n    this.scroll.query(name, Scope.BLOCK) != null ? this.format(name, value) : super.formatAt(index, length, name, value);\n  }\n  insertAt(index, value, def) {\n    if (def == null || this.scroll.query(value, Scope.INLINE) != null)\n      super.insertAt(index, value, def);\n    else {\n      const after = this.split(index);\n      if (after != null) {\n        const blot = this.scroll.create(value, def);\n        after.parent.insertBefore(blot, after);\n      } else\n        throw new Error(\"Attempt to insertAt after block boundaries\");\n    }\n  }\n  replaceWith(name, value) {\n    const replacement = super.replaceWith(name, value);\n    return this.attributes.copy(replacement), replacement;\n  }\n  update(mutations, context) {\n    super.update(mutations, context), mutations.some(\n      (mutation) => mutation.target === this.domNode && mutation.type === \"attributes\"\n    ) && this.attributes.build();\n  }\n};\n_BlockBlot.blotName = \"block\", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = \"P\", _BlockBlot.allowedChildren = [\n  InlineBlot$1,\n  _BlockBlot,\n  LeafBlot$1\n];\nlet BlockBlot = _BlockBlot;\nconst BlockBlot$1 = BlockBlot, _ContainerBlot = class _ContainerBlot extends ParentBlot$1 {\n  checkMerge() {\n    return this.next !== null && this.next.statics.blotName === this.statics.blotName;\n  }\n  deleteAt(index, length) {\n    super.deleteAt(index, length), this.enforceAllowedChildren();\n  }\n  formatAt(index, length, name, value) {\n    super.formatAt(index, length, name, value), this.enforceAllowedChildren();\n  }\n  insertAt(index, value, def) {\n    super.insertAt(index, value, def), this.enforceAllowedChildren();\n  }\n  optimize(context) {\n    super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());\n  }\n};\n_ContainerBlot.blotName = \"container\", _ContainerBlot.scope = Scope.BLOCK_BLOT;\nlet ContainerBlot = _ContainerBlot;\nconst ContainerBlot$1 = ContainerBlot;\nclass EmbedBlot extends LeafBlot$1 {\n  static formats(_domNode, _scroll) {\n  }\n  format(name, value) {\n    super.formatAt(0, this.length(), name, value);\n  }\n  formatAt(index, length, name, value) {\n    index === 0 && length === this.length() ? this.format(name, value) : super.formatAt(index, length, name, value);\n  }\n  formats() {\n    return this.statics.formats(this.domNode, this.scroll);\n  }\n}\nconst EmbedBlot$1 = EmbedBlot, OBSERVER_CONFIG = {\n  attributes: !0,\n  characterData: !0,\n  characterDataOldValue: !0,\n  childList: !0,\n  subtree: !0\n}, MAX_OPTIMIZE_ITERATIONS = 100, _ScrollBlot = class _ScrollBlot extends ParentBlot$1 {\n  constructor(registry, node) {\n    super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver((mutations) => {\n      this.update(mutations);\n    }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();\n  }\n  create(input, value) {\n    return this.registry.create(this, input, value);\n  }\n  find(node, bubble = !1) {\n    const blot = this.registry.find(node, bubble);\n    return blot ? blot.scroll === this ? blot : bubble ? this.find(blot.scroll.domNode.parentNode, !0) : null : null;\n  }\n  query(query, scope = Scope.ANY) {\n    return this.registry.query(query, scope);\n  }\n  register(...definitions) {\n    return this.registry.register(...definitions);\n  }\n  build() {\n    this.scroll != null && super.build();\n  }\n  detach() {\n    super.detach(), this.observer.disconnect();\n  }\n  deleteAt(index, length) {\n    this.update(), index === 0 && length === this.length() ? this.children.forEach((child) => {\n      child.remove();\n    }) : super.deleteAt(index, length);\n  }\n  formatAt(index, length, name, value) {\n    this.update(), super.formatAt(index, length, name, value);\n  }\n  insertAt(index, value, def) {\n    this.update(), super.insertAt(index, value, def);\n  }\n  optimize(mutations = [], context = {}) {\n    super.optimize(context);\n    const mutationsMap = context.mutationsMap || /* @__PURE__ */ new WeakMap();\n    let records = Array.from(this.observer.takeRecords());\n    for (; records.length > 0; )\n      mutations.push(records.pop());\n    const mark = (blot, markParent = !0) => {\n      blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));\n    }, optimize = (blot) => {\n      mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));\n    };\n    let remaining = mutations;\n    for (let i = 0; remaining.length > 0; i += 1) {\n      if (i >= MAX_OPTIMIZE_ITERATIONS)\n        throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n      for (remaining.forEach((mutation) => {\n        const blot = this.find(mutation.target, !0);\n        blot != null && (blot.domNode === mutation.target && (mutation.type === \"childList\" ? (mark(this.find(mutation.previousSibling, !1)), Array.from(mutation.addedNodes).forEach((node) => {\n          const child = this.find(node, !1);\n          mark(child, !1), child instanceof ParentBlot$1 && child.children.forEach((grandChild) => {\n            mark(grandChild, !1);\n          });\n        })) : mutation.type === \"attributes\" && mark(blot.prev)), mark(blot));\n      }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0; )\n        mutations.push(records.pop());\n    }\n  }\n  update(mutations, context = {}) {\n    mutations = mutations || this.observer.takeRecords();\n    const mutationsMap = /* @__PURE__ */ new WeakMap();\n    mutations.map((mutation) => {\n      const blot = this.find(mutation.target, !0);\n      return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);\n    }).forEach((blot) => {\n      blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);\n    }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);\n  }\n};\n_ScrollBlot.blotName = \"scroll\", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = \"DIV\";\nlet ScrollBlot = _ScrollBlot;\nconst ScrollBlot$1 = ScrollBlot, _TextBlot = class _TextBlot extends LeafBlot$1 {\n  static create(value) {\n    return document.createTextNode(value);\n  }\n  static value(domNode) {\n    return domNode.data;\n  }\n  constructor(scroll, node) {\n    super(scroll, node), this.text = this.statics.value(this.domNode);\n  }\n  deleteAt(index, length) {\n    this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n  }\n  index(node, offset) {\n    return this.domNode === node ? offset : -1;\n  }\n  insertAt(index, value, def) {\n    def == null ? (this.text = this.text.slice(0, index) + value + this.text.slice(index), this.domNode.data = this.text) : super.insertAt(index, value, def);\n  }\n  length() {\n    return this.text.length;\n  }\n  optimize(context) {\n    super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());\n  }\n  position(index, _inclusive = !1) {\n    return [this.domNode, index];\n  }\n  split(index, force = !1) {\n    if (!force) {\n      if (index === 0)\n        return this;\n      if (index === this.length())\n        return this.next;\n    }\n    const after = this.scroll.create(this.domNode.splitText(index));\n    return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;\n  }\n  update(mutations, _context) {\n    mutations.some((mutation) => mutation.type === \"characterData\" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));\n  }\n  value() {\n    return this.text;\n  }\n};\n_TextBlot.blotName = \"text\", _TextBlot.scope = Scope.INLINE_BLOT;\nlet TextBlot = _TextBlot;\nconst TextBlot$1 = TextBlot;\n\n//# sourceMappingURL=parchment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcGFyY2htZW50QDMuMC4wL25vZGVfbW9kdWxlcy9wYXJjaG1lbnQvZGlzdC9wYXJjaG1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxraEJBQWtoQjtBQUNsaEI7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLE9BQU87QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGFBQWEsR0FBRyxNQUFNO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtDQUFrQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU8sc0hBQXNILG9CQUFvQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVzdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9wYXJjaG1lbnRAMy4wLjAvbm9kZV9tb2R1bGVzL3BhcmNobWVudC9kaXN0L3BhcmNobWVudC5qcz85MGY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBTY29wZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNjb3BlMikgPT4gKFNjb3BlMltTY29wZTIuVFlQRSA9IDNdID0gXCJUWVBFXCIsIFNjb3BlMltTY29wZTIuTEVWRUwgPSAxMl0gPSBcIkxFVkVMXCIsIFNjb3BlMltTY29wZTIuQVRUUklCVVRFID0gMTNdID0gXCJBVFRSSUJVVEVcIiwgU2NvcGUyW1Njb3BlMi5CTE9UID0gMTRdID0gXCJCTE9UXCIsIFNjb3BlMltTY29wZTIuSU5MSU5FID0gN10gPSBcIklOTElORVwiLCBTY29wZTJbU2NvcGUyLkJMT0NLID0gMTFdID0gXCJCTE9DS1wiLCBTY29wZTJbU2NvcGUyLkJMT0NLX0JMT1QgPSAxMF0gPSBcIkJMT0NLX0JMT1RcIiwgU2NvcGUyW1Njb3BlMi5JTkxJTkVfQkxPVCA9IDZdID0gXCJJTkxJTkVfQkxPVFwiLCBTY29wZTJbU2NvcGUyLkJMT0NLX0FUVFJJQlVURSA9IDldID0gXCJCTE9DS19BVFRSSUJVVEVcIiwgU2NvcGUyW1Njb3BlMi5JTkxJTkVfQVRUUklCVVRFID0gNV0gPSBcIklOTElORV9BVFRSSUJVVEVcIiwgU2NvcGUyW1Njb3BlMi5BTlkgPSAxNV0gPSBcIkFOWVwiLCBTY29wZTIpKShTY29wZSB8fCB7fSk7XG5jbGFzcyBBdHRyaWJ1dG9yIHtcbiAgY29uc3RydWN0b3IoYXR0ck5hbWUsIGtleU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuYXR0ck5hbWUgPSBhdHRyTmFtZSwgdGhpcy5rZXlOYW1lID0ga2V5TmFtZTtcbiAgICBjb25zdCBhdHRyaWJ1dGVCaXQgPSBTY29wZS5UWVBFICYgU2NvcGUuQVRUUklCVVRFO1xuICAgIHRoaXMuc2NvcGUgPSBvcHRpb25zLnNjb3BlICE9IG51bGwgPyAoXG4gICAgICAvLyBJZ25vcmUgdHlwZSBiaXRzLCBmb3JjZSBhdHRyaWJ1dGUgYml0XG4gICAgICBvcHRpb25zLnNjb3BlICYgU2NvcGUuTEVWRUwgfCBhdHRyaWJ1dGVCaXRcbiAgICApIDogU2NvcGUuQVRUUklCVVRFLCBvcHRpb25zLndoaXRlbGlzdCAhPSBudWxsICYmICh0aGlzLndoaXRlbGlzdCA9IG9wdGlvbnMud2hpdGVsaXN0KTtcbiAgfVxuICBzdGF0aWMga2V5cyhub2RlKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKS5tYXAoKGl0ZW0pID0+IGl0ZW0ubmFtZSk7XG4gIH1cbiAgYWRkKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSA/IChub2RlLnNldEF0dHJpYnV0ZSh0aGlzLmtleU5hbWUsIHZhbHVlKSwgITApIDogITE7XG4gIH1cbiAgY2FuQWRkKF9ub2RlLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLndoaXRlbGlzdCA9PSBudWxsID8gITAgOiB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiA/IHRoaXMud2hpdGVsaXN0LmluZGV4T2YodmFsdWUucmVwbGFjZSgvW1wiJ10vZywgXCJcIikpID4gLTEgOiB0aGlzLndoaXRlbGlzdC5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICB9XG4gIHJlbW92ZShub2RlKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUodGhpcy5rZXlOYW1lKTtcbiAgfVxuICB2YWx1ZShub2RlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZSh0aGlzLmtleU5hbWUpO1xuICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgJiYgdmFsdWUgPyB2YWx1ZSA6IFwiXCI7XG4gIH1cbn1cbmNsYXNzIFBhcmNobWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9IFwiW1BhcmNobWVudF0gXCIgKyBtZXNzYWdlLCBzdXBlcihtZXNzYWdlKSwgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSwgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG59XG5jb25zdCBfUmVnaXN0cnkgPSBjbGFzcyBfUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fSwgdGhpcy5jbGFzc2VzID0ge30sIHRoaXMudGFncyA9IHt9LCB0aGlzLnR5cGVzID0ge307XG4gIH1cbiAgc3RhdGljIGZpbmQobm9kZSwgYnViYmxlID0gITEpIHtcbiAgICBpZiAobm9kZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHRoaXMuYmxvdHMuaGFzKG5vZGUpKVxuICAgICAgcmV0dXJuIHRoaXMuYmxvdHMuZ2V0KG5vZGUpIHx8IG51bGw7XG4gICAgaWYgKGJ1YmJsZSkge1xuICAgICAgbGV0IHBhcmVudE5vZGUgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmQocGFyZW50Tm9kZSwgYnViYmxlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY3JlYXRlKHNjcm9sbCwgaW5wdXQsIHZhbHVlKSB7XG4gICAgY29uc3QgbWF0Y2gyID0gdGhpcy5xdWVyeShpbnB1dCk7XG4gICAgaWYgKG1hdGNoMiA9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKGBVbmFibGUgdG8gY3JlYXRlICR7aW5wdXR9IGJsb3RgKTtcbiAgICBjb25zdCBibG90Q2xhc3MgPSBtYXRjaDIsIG5vZGUgPSAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEZpeCBtZSBsYXRlclxuICAgICAgaW5wdXQgaW5zdGFuY2VvZiBOb2RlIHx8IGlucHV0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IGlucHV0IDogYmxvdENsYXNzLmNyZWF0ZSh2YWx1ZSlcbiAgICApLCBibG90ID0gbmV3IGJsb3RDbGFzcyhzY3JvbGwsIG5vZGUsIHZhbHVlKTtcbiAgICByZXR1cm4gX1JlZ2lzdHJ5LmJsb3RzLnNldChibG90LmRvbU5vZGUsIGJsb3QpLCBibG90O1xuICB9XG4gIGZpbmQobm9kZSwgYnViYmxlID0gITEpIHtcbiAgICByZXR1cm4gX1JlZ2lzdHJ5LmZpbmQobm9kZSwgYnViYmxlKTtcbiAgfVxuICBxdWVyeShxdWVyeSwgc2NvcGUgPSBTY29wZS5BTlkpIHtcbiAgICBsZXQgbWF0Y2gyO1xuICAgIHJldHVybiB0eXBlb2YgcXVlcnkgPT0gXCJzdHJpbmdcIiA/IG1hdGNoMiA9IHRoaXMudHlwZXNbcXVlcnldIHx8IHRoaXMuYXR0cmlidXRlc1txdWVyeV0gOiBxdWVyeSBpbnN0YW5jZW9mIFRleHQgfHwgcXVlcnkubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gbWF0Y2gyID0gdGhpcy50eXBlcy50ZXh0IDogdHlwZW9mIHF1ZXJ5ID09IFwibnVtYmVyXCIgPyBxdWVyeSAmIFNjb3BlLkxFVkVMICYgU2NvcGUuQkxPQ0sgPyBtYXRjaDIgPSB0aGlzLnR5cGVzLmJsb2NrIDogcXVlcnkgJiBTY29wZS5MRVZFTCAmIFNjb3BlLklOTElORSAmJiAobWF0Y2gyID0gdGhpcy50eXBlcy5pbmxpbmUpIDogcXVlcnkgaW5zdGFuY2VvZiBFbGVtZW50ICYmICgocXVlcnkuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIikuc3BsaXQoL1xccysvKS5zb21lKChuYW1lKSA9PiAobWF0Y2gyID0gdGhpcy5jbGFzc2VzW25hbWVdLCAhIW1hdGNoMikpLCBtYXRjaDIgPSBtYXRjaDIgfHwgdGhpcy50YWdzW3F1ZXJ5LnRhZ05hbWVdKSwgbWF0Y2gyID09IG51bGwgPyBudWxsIDogXCJzY29wZVwiIGluIG1hdGNoMiAmJiBzY29wZSAmIFNjb3BlLkxFVkVMICYgbWF0Y2gyLnNjb3BlICYmIHNjb3BlICYgU2NvcGUuVFlQRSAmIG1hdGNoMi5zY29wZSA/IG1hdGNoMiA6IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXIoLi4uZGVmaW5pdGlvbnMpIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvbnMubWFwKChkZWZpbml0aW9uKSA9PiB7XG4gICAgICBjb25zdCBpc0Jsb3QgPSBcImJsb3ROYW1lXCIgaW4gZGVmaW5pdGlvbiwgaXNBdHRyID0gXCJhdHRyTmFtZVwiIGluIGRlZmluaXRpb247XG4gICAgICBpZiAoIWlzQmxvdCAmJiAhaXNBdHRyKVxuICAgICAgICB0aHJvdyBuZXcgUGFyY2htZW50RXJyb3IoXCJJbnZhbGlkIGRlZmluaXRpb25cIik7XG4gICAgICBpZiAoaXNCbG90ICYmIGRlZmluaXRpb24uYmxvdE5hbWUgPT09IFwiYWJzdHJhY3RcIilcbiAgICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKFwiQ2Fubm90IHJlZ2lzdGVyIGFic3RyYWN0IGNsYXNzXCIpO1xuICAgICAgY29uc3Qga2V5ID0gaXNCbG90ID8gZGVmaW5pdGlvbi5ibG90TmFtZSA6IGlzQXR0ciA/IGRlZmluaXRpb24uYXR0ck5hbWUgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gdGhpcy50eXBlc1trZXldID0gZGVmaW5pdGlvbiwgaXNBdHRyID8gdHlwZW9mIGRlZmluaXRpb24ua2V5TmFtZSA9PSBcInN0cmluZ1wiICYmICh0aGlzLmF0dHJpYnV0ZXNbZGVmaW5pdGlvbi5rZXlOYW1lXSA9IGRlZmluaXRpb24pIDogaXNCbG90ICYmIChkZWZpbml0aW9uLmNsYXNzTmFtZSAmJiAodGhpcy5jbGFzc2VzW2RlZmluaXRpb24uY2xhc3NOYW1lXSA9IGRlZmluaXRpb24pLCBkZWZpbml0aW9uLnRhZ05hbWUgJiYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi50YWdOYW1lKSA/IGRlZmluaXRpb24udGFnTmFtZSA9IGRlZmluaXRpb24udGFnTmFtZS5tYXAoKHRhZ05hbWUpID0+IHRhZ05hbWUudG9VcHBlckNhc2UoKSkgOiBkZWZpbml0aW9uLnRhZ05hbWUgPSBkZWZpbml0aW9uLnRhZ05hbWUudG9VcHBlckNhc2UoKSwgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbi50YWdOYW1lKSA/IGRlZmluaXRpb24udGFnTmFtZSA6IFtkZWZpbml0aW9uLnRhZ05hbWVdKS5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgKHRoaXMudGFnc1t0YWddID09IG51bGwgfHwgZGVmaW5pdGlvbi5jbGFzc05hbWUgPT0gbnVsbCkgJiYgKHRoaXMudGFnc1t0YWddID0gZGVmaW5pdGlvbik7XG4gICAgICB9KSkpLCBkZWZpbml0aW9uO1xuICAgIH0pO1xuICB9XG59O1xuX1JlZ2lzdHJ5LmJsb3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgUmVnaXN0cnkgPSBfUmVnaXN0cnk7XG5mdW5jdGlvbiBtYXRjaChub2RlLCBwcmVmaXgpIHtcbiAgcmV0dXJuIChub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpLnNwbGl0KC9cXHMrLykuZmlsdGVyKChuYW1lKSA9PiBuYW1lLmluZGV4T2YoYCR7cHJlZml4fS1gKSA9PT0gMCk7XG59XG5jbGFzcyBDbGFzc0F0dHJpYnV0b3IgZXh0ZW5kcyBBdHRyaWJ1dG9yIHtcbiAgc3RhdGljIGtleXMobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKS5zcGxpdCgvXFxzKy8pLm1hcCgobmFtZSkgPT4gbmFtZS5zcGxpdChcIi1cIikuc2xpY2UoMCwgLTEpLmpvaW4oXCItXCIpKTtcbiAgfVxuICBhZGQobm9kZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5BZGQobm9kZSwgdmFsdWUpID8gKHRoaXMucmVtb3ZlKG5vZGUpLCBub2RlLmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5rZXlOYW1lfS0ke3ZhbHVlfWApLCAhMCkgOiAhMTtcbiAgfVxuICByZW1vdmUobm9kZSkge1xuICAgIG1hdGNoKG5vZGUsIHRoaXMua2V5TmFtZSkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgIH0pLCBub2RlLmNsYXNzTGlzdC5sZW5ndGggPT09IDAgJiYgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgfVxuICB2YWx1ZShub2RlKSB7XG4gICAgY29uc3QgdmFsdWUgPSAobWF0Y2gobm9kZSwgdGhpcy5rZXlOYW1lKVswXSB8fCBcIlwiKS5zbGljZSh0aGlzLmtleU5hbWUubGVuZ3RoICsgMSk7XG4gICAgcmV0dXJuIHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSA/IHZhbHVlIDogXCJcIjtcbiAgfVxufVxuY29uc3QgQ2xhc3NBdHRyaWJ1dG9yJDEgPSBDbGFzc0F0dHJpYnV0b3I7XG5mdW5jdGlvbiBjYW1lbGl6ZShuYW1lKSB7XG4gIGNvbnN0IHBhcnRzID0gbmFtZS5zcGxpdChcIi1cIiksIHJlc3QgPSBwYXJ0cy5zbGljZSgxKS5tYXAoKHBhcnQpID0+IHBhcnRbMF0udG9VcHBlckNhc2UoKSArIHBhcnQuc2xpY2UoMSkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBwYXJ0c1swXSArIHJlc3Q7XG59XG5jbGFzcyBTdHlsZUF0dHJpYnV0b3IgZXh0ZW5kcyBBdHRyaWJ1dG9yIHtcbiAgc3RhdGljIGtleXMobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSB8fCBcIlwiKS5zcGxpdChcIjtcIikubWFwKCh2YWx1ZSkgPT4gdmFsdWUuc3BsaXQoXCI6XCIpWzBdLnRyaW0oKSk7XG4gIH1cbiAgYWRkKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FuQWRkKG5vZGUsIHZhbHVlKSA/IChub2RlLnN0eWxlW2NhbWVsaXplKHRoaXMua2V5TmFtZSldID0gdmFsdWUsICEwKSA6ICExO1xuICB9XG4gIHJlbW92ZShub2RlKSB7XG4gICAgbm9kZS5zdHlsZVtjYW1lbGl6ZSh0aGlzLmtleU5hbWUpXSA9IFwiXCIsIG5vZGUuZ2V0QXR0cmlidXRlKFwic3R5bGVcIikgfHwgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoXCJzdHlsZVwiKTtcbiAgfVxuICB2YWx1ZShub2RlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBub2RlLnN0eWxlW2NhbWVsaXplKHRoaXMua2V5TmFtZSldO1xuICAgIHJldHVybiB0aGlzLmNhbkFkZChub2RlLCB2YWx1ZSkgPyB2YWx1ZSA6IFwiXCI7XG4gIH1cbn1cbmNvbnN0IFN0eWxlQXR0cmlidXRvciQxID0gU3R5bGVBdHRyaWJ1dG9yO1xuY2xhc3MgQXR0cmlidXRvclN0b3JlIHtcbiAgY29uc3RydWN0b3IoZG9tTm9kZSkge1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9LCB0aGlzLmRvbU5vZGUgPSBkb21Ob2RlLCB0aGlzLmJ1aWxkKCk7XG4gIH1cbiAgYXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICB2YWx1ZSA/IGF0dHJpYnV0ZS5hZGQodGhpcy5kb21Ob2RlLCB2YWx1ZSkgJiYgKGF0dHJpYnV0ZS52YWx1ZSh0aGlzLmRvbU5vZGUpICE9IG51bGwgPyB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLmF0dHJOYW1lXSA9IGF0dHJpYnV0ZSA6IGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlLmF0dHJOYW1lXSkgOiAoYXR0cmlidXRlLnJlbW92ZSh0aGlzLmRvbU5vZGUpLCBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZS5hdHRyTmFtZV0pO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGJsb3QgPSBSZWdpc3RyeS5maW5kKHRoaXMuZG9tTm9kZSk7XG4gICAgaWYgKGJsb3QgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gQXR0cmlidXRvci5rZXlzKHRoaXMuZG9tTm9kZSksIGNsYXNzZXMgPSBDbGFzc0F0dHJpYnV0b3IkMS5rZXlzKHRoaXMuZG9tTm9kZSksIHN0eWxlcyA9IFN0eWxlQXR0cmlidXRvciQxLmtleXModGhpcy5kb21Ob2RlKTtcbiAgICBhdHRyaWJ1dGVzLmNvbmNhdChjbGFzc2VzKS5jb25jYXQoc3R5bGVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCBhdHRyID0gYmxvdC5zY3JvbGwucXVlcnkobmFtZSwgU2NvcGUuQVRUUklCVVRFKTtcbiAgICAgIGF0dHIgaW5zdGFuY2VvZiBBdHRyaWJ1dG9yICYmICh0aGlzLmF0dHJpYnV0ZXNbYXR0ci5hdHRyTmFtZV0gPSBhdHRyKTtcbiAgICB9KTtcbiAgfVxuICBjb3B5KHRhcmdldCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYXR0cmlidXRlc1trZXldLnZhbHVlKHRoaXMuZG9tTm9kZSk7XG4gICAgICB0YXJnZXQuZm9ybWF0KGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIG1vdmUodGFyZ2V0KSB7XG4gICAgdGhpcy5jb3B5KHRhcmdldCksIE9iamVjdC5rZXlzKHRoaXMuYXR0cmlidXRlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNba2V5XS5yZW1vdmUodGhpcy5kb21Ob2RlKTtcbiAgICB9KSwgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gIH1cbiAgdmFsdWVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmF0dHJpYnV0ZXMpLnJlZHVjZShcbiAgICAgIChhdHRyaWJ1dGVzLCBuYW1lKSA9PiAoYXR0cmlidXRlc1tuYW1lXSA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXS52YWx1ZSh0aGlzLmRvbU5vZGUpLCBhdHRyaWJ1dGVzKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxufVxuY29uc3QgQXR0cmlidXRvclN0b3JlJDEgPSBBdHRyaWJ1dG9yU3RvcmUsIF9TaGFkb3dCbG90ID0gY2xhc3MgX1NoYWRvd0Jsb3Qge1xuICBjb25zdHJ1Y3RvcihzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbCwgdGhpcy5kb21Ob2RlID0gZG9tTm9kZSwgUmVnaXN0cnkuYmxvdHMuc2V0KGRvbU5vZGUsIHRoaXMpLCB0aGlzLnByZXYgPSBudWxsLCB0aGlzLm5leHQgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUocmF3VmFsdWUpIHtcbiAgICBpZiAodGhpcy50YWdOYW1lID09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgUGFyY2htZW50RXJyb3IoXCJCbG90IGRlZmluaXRpb24gbWlzc2luZyB0YWdOYW1lXCIpO1xuICAgIGxldCBub2RlLCB2YWx1ZTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLnRhZ05hbWUpID8gKHR5cGVvZiByYXdWYWx1ZSA9PSBcInN0cmluZ1wiID8gKHZhbHVlID0gcmF3VmFsdWUudG9VcHBlckNhc2UoKSwgcGFyc2VJbnQodmFsdWUsIDEwKS50b1N0cmluZygpID09PSB2YWx1ZSAmJiAodmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApKSkgOiB0eXBlb2YgcmF3VmFsdWUgPT0gXCJudW1iZXJcIiAmJiAodmFsdWUgPSByYXdWYWx1ZSksIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy50YWdOYW1lW3ZhbHVlIC0gMV0pIDogdmFsdWUgJiYgdGhpcy50YWdOYW1lLmluZGV4T2YodmFsdWUpID4gLTEgPyBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh2YWx1ZSkgOiBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWVbMF0pKSA6IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnTmFtZSksIHRoaXMuY2xhc3NOYW1lICYmIG5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZSksIG5vZGU7XG4gIH1cbiAgLy8gSGFjayBmb3IgYWNjZXNzaW5nIGluaGVyaXRlZCBzdGF0aWMgbWV0aG9kc1xuICBnZXQgc3RhdGljcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgfVxuICBhdHRhY2goKSB7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgZG9tTm9kZSA9IHRoaXMuZG9tTm9kZS5jbG9uZU5vZGUoITEpO1xuICAgIHJldHVybiB0aGlzLnNjcm9sbC5jcmVhdGUoZG9tTm9kZSk7XG4gIH1cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMucGFyZW50ICE9IG51bGwgJiYgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyksIFJlZ2lzdHJ5LmJsb3RzLmRlbGV0ZSh0aGlzLmRvbU5vZGUpO1xuICB9XG4gIGRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpIHtcbiAgICB0aGlzLmlzb2xhdGUoaW5kZXgsIGxlbmd0aCkucmVtb3ZlKCk7XG4gIH1cbiAgZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBibG90ID0gdGhpcy5pc29sYXRlKGluZGV4LCBsZW5ndGgpO1xuICAgIGlmICh0aGlzLnNjcm9sbC5xdWVyeShuYW1lLCBTY29wZS5CTE9UKSAhPSBudWxsICYmIHZhbHVlKVxuICAgICAgYmxvdC53cmFwKG5hbWUsIHZhbHVlKTtcbiAgICBlbHNlIGlmICh0aGlzLnNjcm9sbC5xdWVyeShuYW1lLCBTY29wZS5BVFRSSUJVVEUpICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc2Nyb2xsLmNyZWF0ZSh0aGlzLnN0YXRpY3Muc2NvcGUpO1xuICAgICAgYmxvdC53cmFwKHBhcmVudCksIHBhcmVudC5mb3JtYXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBpbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZikge1xuICAgIGNvbnN0IGJsb3QgPSBkZWYgPT0gbnVsbCA/IHRoaXMuc2Nyb2xsLmNyZWF0ZShcInRleHRcIiwgdmFsdWUpIDogdGhpcy5zY3JvbGwuY3JlYXRlKHZhbHVlLCBkZWYpLCByZWYgPSB0aGlzLnNwbGl0KGluZGV4KTtcbiAgICB0aGlzLnBhcmVudC5pbnNlcnRCZWZvcmUoYmxvdCwgcmVmIHx8IHZvaWQgMCk7XG4gIH1cbiAgaXNvbGF0ZShpbmRleCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdCB0byBpc29sYXRlIGF0IGVuZFwiKTtcbiAgICByZXR1cm4gdGFyZ2V0LnNwbGl0KGxlbmd0aCksIHRhcmdldDtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgb2Zmc2V0KHJvb3QgPSB0aGlzLnBhcmVudCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA9PSBudWxsIHx8IHRoaXMgPT09IHJvb3QgPyAwIDogdGhpcy5wYXJlbnQuY2hpbGRyZW4ub2Zmc2V0KHRoaXMpICsgdGhpcy5wYXJlbnQub2Zmc2V0KHJvb3QpO1xuICB9XG4gIG9wdGltaXplKF9jb250ZXh0KSB7XG4gICAgdGhpcy5zdGF0aWNzLnJlcXVpcmVkQ29udGFpbmVyICYmICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiB0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIpICYmIHRoaXMud3JhcCh0aGlzLnN0YXRpY3MucmVxdWlyZWRDb250YWluZXIuYmxvdE5hbWUpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmRvbU5vZGUucGFyZW50Tm9kZSAhPSBudWxsICYmIHRoaXMuZG9tTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZG9tTm9kZSksIHRoaXMuZGV0YWNoKCk7XG4gIH1cbiAgcmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudCA9IHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIgPyB0aGlzLnNjcm9sbC5jcmVhdGUobmFtZSwgdmFsdWUpIDogbmFtZTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgIT0gbnVsbCAmJiAodGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHJlcGxhY2VtZW50LCB0aGlzLm5leHQgfHwgdm9pZCAwKSwgdGhpcy5yZW1vdmUoKSksIHJlcGxhY2VtZW50O1xuICB9XG4gIHNwbGl0KGluZGV4LCBfZm9yY2UpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IDAgPyB0aGlzIDogdGhpcy5uZXh0O1xuICB9XG4gIHVwZGF0ZShfbXV0YXRpb25zLCBfY29udGV4dCkge1xuICB9XG4gIHdyYXAobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gdHlwZW9mIG5hbWUgPT0gXCJzdHJpbmdcIiA/IHRoaXMuc2Nyb2xsLmNyZWF0ZShuYW1lLCB2YWx1ZSkgOiBuYW1lO1xuICAgIGlmICh0aGlzLnBhcmVudCAhPSBudWxsICYmIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh3cmFwcGVyLCB0aGlzLm5leHQgfHwgdm9pZCAwKSwgdHlwZW9mIHdyYXBwZXIuYXBwZW5kQ2hpbGQgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFBhcmNobWVudEVycm9yKGBDYW5ub3Qgd3JhcCAke25hbWV9YCk7XG4gICAgcmV0dXJuIHdyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcyksIHdyYXBwZXI7XG4gIH1cbn07XG5fU2hhZG93QmxvdC5ibG90TmFtZSA9IFwiYWJzdHJhY3RcIjtcbmxldCBTaGFkb3dCbG90ID0gX1NoYWRvd0Jsb3Q7XG5jb25zdCBfTGVhZkJsb3QgPSBjbGFzcyBfTGVhZkJsb3QgZXh0ZW5kcyBTaGFkb3dCbG90IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGJ5IGRvbU5vZGUgaWYgaXQgaXMgdGhpcyBCbG90J3MgdHlwZVxuICAgKiBObyBjaGVja2luZyB0aGF0IGRvbU5vZGUgY2FuIHJlcHJlc2VudCB0aGlzIEJsb3QgdHlwZSBpcyByZXF1aXJlZCBzb1xuICAgKiBhcHBsaWNhdGlvbnMgbmVlZGluZyBpdCBzaG91bGQgY2hlY2sgZXh0ZXJuYWxseSBiZWZvcmUgY2FsbGluZy5cbiAgICovXG4gIHN0YXRpYyB2YWx1ZShfZG9tTm9kZSkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gbG9jYXRpb24gcmVwcmVzZW50ZWQgYnkgbm9kZSBhbmQgb2Zmc2V0IGZyb20gRE9NIFNlbGVjdGlvbiBSYW5nZSxcbiAgICogcmV0dXJuIGluZGV4IHRvIHRoYXQgbG9jYXRpb24uXG4gICAqL1xuICBpbmRleChub2RlLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5kb21Ob2RlID09PSBub2RlIHx8IHRoaXMuZG9tTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZID8gTWF0aC5taW4ob2Zmc2V0LCAxKSA6IC0xO1xuICB9XG4gIC8qKlxuICAgKiBHaXZlbiBpbmRleCB0byBsb2NhdGlvbiB3aXRoaW4gYmxvdCwgcmV0dXJuIG5vZGUgYW5kIG9mZnNldCByZXByZXNlbnRpbmdcbiAgICogdGhhdCBsb2NhdGlvbiwgY29uc3VtYWJsZSBieSBET00gU2VsZWN0aW9uIFJhbmdlXG4gICAqL1xuICBwb3NpdGlvbihpbmRleCwgX2luY2x1c2l2ZSkge1xuICAgIGxldCBvZmZzZXQgPSBBcnJheS5mcm9tKHRoaXMucGFyZW50LmRvbU5vZGUuY2hpbGROb2RlcykuaW5kZXhPZih0aGlzLmRvbU5vZGUpO1xuICAgIHJldHVybiBpbmRleCA+IDAgJiYgKG9mZnNldCArPSAxKSwgW3RoaXMucGFyZW50LmRvbU5vZGUsIG9mZnNldF07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGlzIGJsb3RcbiAgICogU2hvdWxkIG5vdCBjaGFuZ2Ugd2l0aG91dCBpbnRlcmFjdGlvbiBmcm9tIEFQSSBvclxuICAgKiB1c2VyIGNoYW5nZSBkZXRlY3RhYmxlIGJ5IHVwZGF0ZSgpXG4gICAqL1xuICB2YWx1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW3RoaXMuc3RhdGljcy5ibG90TmFtZV06IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpIHx8ICEwXG4gICAgfTtcbiAgfVxufTtcbl9MZWFmQmxvdC5zY29wZSA9IFNjb3BlLklOTElORV9CTE9UO1xubGV0IExlYWZCbG90ID0gX0xlYWZCbG90O1xuY29uc3QgTGVhZkJsb3QkMSA9IExlYWZCbG90O1xuY2xhc3MgTGlua2VkTGlzdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhZCA9IG51bGwsIHRoaXMudGFpbCA9IG51bGwsIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuICBhcHBlbmQoLi4ubm9kZXMpIHtcbiAgICBpZiAodGhpcy5pbnNlcnRCZWZvcmUobm9kZXNbMF0sIG51bGwpLCBub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCByZXN0ID0gbm9kZXMuc2xpY2UoMSk7XG4gICAgICB0aGlzLmFwcGVuZCguLi5yZXN0KTtcbiAgICB9XG4gIH1cbiAgYXQoaW5kZXgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIGxldCBjdXIgPSBuZXh0KCk7XG4gICAgZm9yICg7IGN1ciAmJiBpbmRleCA+IDA7IClcbiAgICAgIGluZGV4IC09IDEsIGN1ciA9IG5leHQoKTtcbiAgICByZXR1cm4gY3VyO1xuICB9XG4gIGNvbnRhaW5zKG5vZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIGxldCBjdXIgPSBuZXh0KCk7XG4gICAgZm9yICg7IGN1cjsgKSB7XG4gICAgICBpZiAoY3VyID09PSBub2RlKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBjdXIgPSBuZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBpbmRleE9mKG5vZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIGxldCBjdXIgPSBuZXh0KCksIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgY3VyOyApIHtcbiAgICAgIGlmIChjdXIgPT09IG5vZGUpXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIGluZGV4ICs9IDEsIGN1ciA9IG5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGluc2VydEJlZm9yZShub2RlLCByZWZOb2RlKSB7XG4gICAgbm9kZSAhPSBudWxsICYmICh0aGlzLnJlbW92ZShub2RlKSwgbm9kZS5uZXh0ID0gcmVmTm9kZSwgcmVmTm9kZSAhPSBudWxsID8gKG5vZGUucHJldiA9IHJlZk5vZGUucHJldiwgcmVmTm9kZS5wcmV2ICE9IG51bGwgJiYgKHJlZk5vZGUucHJldi5uZXh0ID0gbm9kZSksIHJlZk5vZGUucHJldiA9IG5vZGUsIHJlZk5vZGUgPT09IHRoaXMuaGVhZCAmJiAodGhpcy5oZWFkID0gbm9kZSkpIDogdGhpcy50YWlsICE9IG51bGwgPyAodGhpcy50YWlsLm5leHQgPSBub2RlLCBub2RlLnByZXYgPSB0aGlzLnRhaWwsIHRoaXMudGFpbCA9IG5vZGUpIDogKG5vZGUucHJldiA9IG51bGwsIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5vZGUpLCB0aGlzLmxlbmd0aCArPSAxKTtcbiAgfVxuICBvZmZzZXQodGFyZ2V0KSB7XG4gICAgbGV0IGluZGV4ID0gMCwgY3VyID0gdGhpcy5oZWFkO1xuICAgIGZvciAoOyBjdXIgIT0gbnVsbDsgKSB7XG4gICAgICBpZiAoY3VyID09PSB0YXJnZXQpXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIGluZGV4ICs9IGN1ci5sZW5ndGgoKSwgY3VyID0gY3VyLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICByZW1vdmUobm9kZSkge1xuICAgIHRoaXMuY29udGFpbnMobm9kZSkgJiYgKG5vZGUucHJldiAhPSBudWxsICYmIChub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dCksIG5vZGUubmV4dCAhPSBudWxsICYmIChub2RlLm5leHQucHJldiA9IG5vZGUucHJldiksIG5vZGUgPT09IHRoaXMuaGVhZCAmJiAodGhpcy5oZWFkID0gbm9kZS5uZXh0KSwgbm9kZSA9PT0gdGhpcy50YWlsICYmICh0aGlzLnRhaWwgPSBub2RlLnByZXYpLCB0aGlzLmxlbmd0aCAtPSAxKTtcbiAgfVxuICBpdGVyYXRvcihjdXJOb2RlID0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnN0IHJldCA9IGN1ck5vZGU7XG4gICAgICByZXR1cm4gY3VyTm9kZSAhPSBudWxsICYmIChjdXJOb2RlID0gY3VyTm9kZS5uZXh0KSwgcmV0O1xuICAgIH07XG4gIH1cbiAgZmluZChpbmRleCwgaW5jbHVzaXZlID0gITEpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pdGVyYXRvcigpO1xuICAgIGxldCBjdXIgPSBuZXh0KCk7XG4gICAgZm9yICg7IGN1cjsgKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBjdXIubGVuZ3RoKCk7XG4gICAgICBpZiAoaW5kZXggPCBsZW5ndGggfHwgaW5jbHVzaXZlICYmIGluZGV4ID09PSBsZW5ndGggJiYgKGN1ci5uZXh0ID09IG51bGwgfHwgY3VyLm5leHQubGVuZ3RoKCkgIT09IDApKVxuICAgICAgICByZXR1cm4gW2N1ciwgaW5kZXhdO1xuICAgICAgaW5kZXggLT0gbGVuZ3RoLCBjdXIgPSBuZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBbbnVsbCwgMF07XG4gIH1cbiAgZm9yRWFjaChjYWxsYmFjaykge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgbGV0IGN1ciA9IG5leHQoKTtcbiAgICBmb3IgKDsgY3VyOyApXG4gICAgICBjYWxsYmFjayhjdXIpLCBjdXIgPSBuZXh0KCk7XG4gIH1cbiAgZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGxlbmd0aCA8PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IFtzdGFydE5vZGUsIG9mZnNldF0gPSB0aGlzLmZpbmQoaW5kZXgpO1xuICAgIGxldCBjdXJJbmRleCA9IGluZGV4IC0gb2Zmc2V0O1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLml0ZXJhdG9yKHN0YXJ0Tm9kZSk7XG4gICAgbGV0IGN1ciA9IG5leHQoKTtcbiAgICBmb3IgKDsgY3VyICYmIGN1ckluZGV4IDwgaW5kZXggKyBsZW5ndGg7ICkge1xuICAgICAgY29uc3QgY3VyTGVuZ3RoID0gY3VyLmxlbmd0aCgpO1xuICAgICAgaW5kZXggPiBjdXJJbmRleCA/IGNhbGxiYWNrKFxuICAgICAgICBjdXIsXG4gICAgICAgIGluZGV4IC0gY3VySW5kZXgsXG4gICAgICAgIE1hdGgubWluKGxlbmd0aCwgY3VySW5kZXggKyBjdXJMZW5ndGggLSBpbmRleClcbiAgICAgICkgOiBjYWxsYmFjayhjdXIsIDAsIE1hdGgubWluKGN1ckxlbmd0aCwgaW5kZXggKyBsZW5ndGggLSBjdXJJbmRleCkpLCBjdXJJbmRleCArPSBjdXJMZW5ndGgsIGN1ciA9IG5leHQoKTtcbiAgICB9XG4gIH1cbiAgbWFwKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKChtZW1vLCBjdXIpID0+IChtZW1vLnB1c2goY2FsbGJhY2soY3VyKSksIG1lbW8pLCBbXSk7XG4gIH1cbiAgcmVkdWNlKGNhbGxiYWNrLCBtZW1vKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICBsZXQgY3VyID0gbmV4dCgpO1xuICAgIGZvciAoOyBjdXI7IClcbiAgICAgIG1lbW8gPSBjYWxsYmFjayhtZW1vLCBjdXIpLCBjdXIgPSBuZXh0KCk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH1cbn1cbmZ1bmN0aW9uIG1ha2VBdHRhY2hlZEJsb3Qobm9kZSwgc2Nyb2xsKSB7XG4gIGNvbnN0IGZvdW5kID0gc2Nyb2xsLmZpbmQobm9kZSk7XG4gIGlmIChmb3VuZClcbiAgICByZXR1cm4gZm91bmQ7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNjcm9sbC5jcmVhdGUobm9kZSk7XG4gIH0gY2F0Y2gge1xuICAgIGNvbnN0IGJsb3QgPSBzY3JvbGwuY3JlYXRlKFNjb3BlLklOTElORSk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgYmxvdC5kb21Ob2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9KSwgbm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYmxvdC5kb21Ob2RlLCBub2RlKSwgYmxvdC5hdHRhY2goKSwgYmxvdDtcbiAgfVxufVxuY29uc3QgX1BhcmVudEJsb3QgPSBjbGFzcyBfUGFyZW50QmxvdCBleHRlbmRzIFNoYWRvd0Jsb3Qge1xuICBjb25zdHJ1Y3RvcihzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICBzdXBlcihzY3JvbGwsIGRvbU5vZGUpLCB0aGlzLnVpTm9kZSA9IG51bGwsIHRoaXMuYnVpbGQoKTtcbiAgfVxuICBhcHBlbmRDaGlsZChvdGhlcikge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG90aGVyKTtcbiAgfVxuICBhdHRhY2goKSB7XG4gICAgc3VwZXIuYXR0YWNoKCksIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNoaWxkLmF0dGFjaCgpO1xuICAgIH0pO1xuICB9XG4gIGF0dGFjaFVJKG5vZGUpIHtcbiAgICB0aGlzLnVpTm9kZSAhPSBudWxsICYmIHRoaXMudWlOb2RlLnJlbW92ZSgpLCB0aGlzLnVpTm9kZSA9IG5vZGUsIF9QYXJlbnRCbG90LnVpQ2xhc3MgJiYgdGhpcy51aU5vZGUuY2xhc3NMaXN0LmFkZChfUGFyZW50QmxvdC51aUNsYXNzKSwgdGhpcy51aU5vZGUuc2V0QXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIsIFwiZmFsc2VcIiksIHRoaXMuZG9tTm9kZS5pbnNlcnRCZWZvcmUodGhpcy51aU5vZGUsIHRoaXMuZG9tTm9kZS5maXJzdENoaWxkKTtcbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24sIHNob3VsZCBmaWxsIGl0cyBvd24gY2hpbGRyZW4gTGlua2VkTGlzdC5cbiAgICovXG4gIGJ1aWxkKCkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgTGlua2VkTGlzdCgpLCBBcnJheS5mcm9tKHRoaXMuZG9tTm9kZS5jaGlsZE5vZGVzKS5maWx0ZXIoKG5vZGUpID0+IG5vZGUgIT09IHRoaXMudWlOb2RlKS5yZXZlcnNlKCkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBtYWtlQXR0YWNoZWRCbG90KG5vZGUsIHRoaXMuc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQsIHRoaXMuY2hpbGRyZW4uaGVhZCB8fCB2b2lkIDApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQYXJjaG1lbnRFcnJvcilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBkZWxldGVBdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgaWYgKGluZGV4ID09PSAwICYmIGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgoKSlcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIChjaGlsZCwgb2Zmc2V0LCBjaGlsZExlbmd0aCkgPT4ge1xuICAgICAgY2hpbGQuZGVsZXRlQXQob2Zmc2V0LCBjaGlsZExlbmd0aCk7XG4gICAgfSk7XG4gIH1cbiAgZGVzY2VuZGFudChjcml0ZXJpYSwgaW5kZXggPSAwKSB7XG4gICAgY29uc3QgW2NoaWxkLCBvZmZzZXRdID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4KTtcbiAgICByZXR1cm4gY3JpdGVyaWEuYmxvdE5hbWUgPT0gbnVsbCAmJiBjcml0ZXJpYShjaGlsZCkgfHwgY3JpdGVyaWEuYmxvdE5hbWUgIT0gbnVsbCAmJiBjaGlsZCBpbnN0YW5jZW9mIGNyaXRlcmlhID8gW2NoaWxkLCBvZmZzZXRdIDogY2hpbGQgaW5zdGFuY2VvZiBfUGFyZW50QmxvdCA/IGNoaWxkLmRlc2NlbmRhbnQoY3JpdGVyaWEsIG9mZnNldCkgOiBbbnVsbCwgLTFdO1xuICB9XG4gIGRlc2NlbmRhbnRzKGNyaXRlcmlhLCBpbmRleCA9IDAsIGxlbmd0aCA9IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICBsZXQgZGVzY2VuZGFudHMgPSBbXSwgbGVuZ3RoTGVmdCA9IGxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoXG4gICAgICBpbmRleCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIChjaGlsZCwgY2hpbGRJbmRleCwgY2hpbGRMZW5ndGgpID0+IHtcbiAgICAgICAgKGNyaXRlcmlhLmJsb3ROYW1lID09IG51bGwgJiYgY3JpdGVyaWEoY2hpbGQpIHx8IGNyaXRlcmlhLmJsb3ROYW1lICE9IG51bGwgJiYgY2hpbGQgaW5zdGFuY2VvZiBjcml0ZXJpYSkgJiYgZGVzY2VuZGFudHMucHVzaChjaGlsZCksIGNoaWxkIGluc3RhbmNlb2YgX1BhcmVudEJsb3QgJiYgKGRlc2NlbmRhbnRzID0gZGVzY2VuZGFudHMuY29uY2F0KFxuICAgICAgICAgIGNoaWxkLmRlc2NlbmRhbnRzKGNyaXRlcmlhLCBjaGlsZEluZGV4LCBsZW5ndGhMZWZ0KVxuICAgICAgICApKSwgbGVuZ3RoTGVmdCAtPSBjaGlsZExlbmd0aDtcbiAgICAgIH1cbiAgICApLCBkZXNjZW5kYW50cztcbiAgfVxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY2hpbGQuZGV0YWNoKCk7XG4gICAgfSksIHN1cGVyLmRldGFjaCgpO1xuICB9XG4gIGVuZm9yY2VBbGxvd2VkQ2hpbGRyZW4oKSB7XG4gICAgbGV0IGRvbmUgPSAhMTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBkb25lIHx8IHRoaXMuc3RhdGljcy5hbGxvd2VkQ2hpbGRyZW4uc29tZShcbiAgICAgICAgKGRlZikgPT4gY2hpbGQgaW5zdGFuY2VvZiBkZWZcbiAgICAgICkgfHwgKGNoaWxkLnN0YXRpY3Muc2NvcGUgPT09IFNjb3BlLkJMT0NLX0JMT1QgPyAoY2hpbGQubmV4dCAhPSBudWxsICYmIHRoaXMuc3BsaXRBZnRlcihjaGlsZCksIGNoaWxkLnByZXYgIT0gbnVsbCAmJiB0aGlzLnNwbGl0QWZ0ZXIoY2hpbGQucHJldiksIGNoaWxkLnBhcmVudC51bndyYXAoKSwgZG9uZSA9ICEwKSA6IGNoaWxkIGluc3RhbmNlb2YgX1BhcmVudEJsb3QgPyBjaGlsZC51bndyYXAoKSA6IGNoaWxkLnJlbW92ZSgpKTtcbiAgICB9KTtcbiAgfVxuICBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaEF0KGluZGV4LCBsZW5ndGgsIChjaGlsZCwgb2Zmc2V0LCBjaGlsZExlbmd0aCkgPT4ge1xuICAgICAgY2hpbGQuZm9ybWF0QXQob2Zmc2V0LCBjaGlsZExlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgY29uc3QgW2NoaWxkLCBvZmZzZXRdID0gdGhpcy5jaGlsZHJlbi5maW5kKGluZGV4KTtcbiAgICBpZiAoY2hpbGQpXG4gICAgICBjaGlsZC5pbnNlcnRBdChvZmZzZXQsIHZhbHVlLCBkZWYpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgYmxvdCA9IGRlZiA9PSBudWxsID8gdGhpcy5zY3JvbGwuY3JlYXRlKFwidGV4dFwiLCB2YWx1ZSkgOiB0aGlzLnNjcm9sbC5jcmVhdGUodmFsdWUsIGRlZik7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGJsb3QpO1xuICAgIH1cbiAgfVxuICBpbnNlcnRCZWZvcmUoY2hpbGRCbG90LCByZWZCbG90KSB7XG4gICAgY2hpbGRCbG90LnBhcmVudCAhPSBudWxsICYmIGNoaWxkQmxvdC5wYXJlbnQuY2hpbGRyZW4ucmVtb3ZlKGNoaWxkQmxvdCk7XG4gICAgbGV0IHJlZkRvbU5vZGUgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4uaW5zZXJ0QmVmb3JlKGNoaWxkQmxvdCwgcmVmQmxvdCB8fCBudWxsKSwgY2hpbGRCbG90LnBhcmVudCA9IHRoaXMsIHJlZkJsb3QgIT0gbnVsbCAmJiAocmVmRG9tTm9kZSA9IHJlZkJsb3QuZG9tTm9kZSksICh0aGlzLmRvbU5vZGUucGFyZW50Tm9kZSAhPT0gY2hpbGRCbG90LmRvbU5vZGUgfHwgdGhpcy5kb21Ob2RlLm5leHRTaWJsaW5nICE9PSByZWZEb21Ob2RlKSAmJiB0aGlzLmRvbU5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkQmxvdC5kb21Ob2RlLCByZWZEb21Ob2RlKSwgY2hpbGRCbG90LmF0dGFjaCgpO1xuICB9XG4gIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5yZWR1Y2UoKG1lbW8sIGNoaWxkKSA9PiBtZW1vICsgY2hpbGQubGVuZ3RoKCksIDApO1xuICB9XG4gIG1vdmVDaGlsZHJlbih0YXJnZXRQYXJlbnQsIHJlZk5vZGUpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICB0YXJnZXRQYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCByZWZOb2RlKTtcbiAgICB9KTtcbiAgfVxuICBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgaWYgKHN1cGVyLm9wdGltaXplKGNvbnRleHQpLCB0aGlzLmVuZm9yY2VBbGxvd2VkQ2hpbGRyZW4oKSwgdGhpcy51aU5vZGUgIT0gbnVsbCAmJiB0aGlzLnVpTm9kZSAhPT0gdGhpcy5kb21Ob2RlLmZpcnN0Q2hpbGQgJiYgdGhpcy5kb21Ob2RlLmluc2VydEJlZm9yZSh0aGlzLnVpTm9kZSwgdGhpcy5kb21Ob2RlLmZpcnN0Q2hpbGQpLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMClcbiAgICAgIGlmICh0aGlzLnN0YXRpY3MuZGVmYXVsdENoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLnNjcm9sbC5jcmVhdGUodGhpcy5zdGF0aWNzLmRlZmF1bHRDaGlsZC5ibG90TmFtZSk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cbiAgcGF0aChpbmRleCwgaW5jbHVzaXZlID0gITEpIHtcbiAgICBjb25zdCBbY2hpbGQsIG9mZnNldF0gPSB0aGlzLmNoaWxkcmVuLmZpbmQoaW5kZXgsIGluY2x1c2l2ZSksIHBvc2l0aW9uID0gW1t0aGlzLCBpbmRleF1dO1xuICAgIHJldHVybiBjaGlsZCBpbnN0YW5jZW9mIF9QYXJlbnRCbG90ID8gcG9zaXRpb24uY29uY2F0KGNoaWxkLnBhdGgob2Zmc2V0LCBpbmNsdXNpdmUpKSA6IChjaGlsZCAhPSBudWxsICYmIHBvc2l0aW9uLnB1c2goW2NoaWxkLCBvZmZzZXRdKSwgcG9zaXRpb24pO1xuICB9XG4gIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgdGhpcy5jaGlsZHJlbi5yZW1vdmUoY2hpbGQpO1xuICB9XG4gIHJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSB0eXBlb2YgbmFtZSA9PSBcInN0cmluZ1wiID8gdGhpcy5zY3JvbGwuY3JlYXRlKG5hbWUsIHZhbHVlKSA6IG5hbWU7XG4gICAgcmV0dXJuIHJlcGxhY2VtZW50IGluc3RhbmNlb2YgX1BhcmVudEJsb3QgJiYgdGhpcy5tb3ZlQ2hpbGRyZW4ocmVwbGFjZW1lbnQpLCBzdXBlci5yZXBsYWNlV2l0aChyZXBsYWNlbWVudCk7XG4gIH1cbiAgc3BsaXQoaW5kZXgsIGZvcmNlID0gITEpIHtcbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmxlbmd0aCgpKVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0O1xuICAgIH1cbiAgICBjb25zdCBhZnRlciA9IHRoaXMuY2xvbmUoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGFmdGVyLCB0aGlzLm5leHQgfHwgdm9pZCAwKSwgdGhpcy5jaGlsZHJlbi5mb3JFYWNoQXQoaW5kZXgsIHRoaXMubGVuZ3RoKCksIChjaGlsZCwgb2Zmc2V0LCBfbGVuZ3RoKSA9PiB7XG4gICAgICBjb25zdCBzcGxpdCA9IGNoaWxkLnNwbGl0KG9mZnNldCwgZm9yY2UpO1xuICAgICAgc3BsaXQgIT0gbnVsbCAmJiBhZnRlci5hcHBlbmRDaGlsZChzcGxpdCk7XG4gICAgfSksIGFmdGVyO1xuICB9XG4gIHNwbGl0QWZ0ZXIoY2hpbGQpIHtcbiAgICBjb25zdCBhZnRlciA9IHRoaXMuY2xvbmUoKTtcbiAgICBmb3IgKDsgY2hpbGQubmV4dCAhPSBudWxsOyApXG4gICAgICBhZnRlci5hcHBlbmRDaGlsZChjaGlsZC5uZXh0KTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGFmdGVyLCB0aGlzLm5leHQgfHwgdm9pZCAwKSwgYWZ0ZXI7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHRoaXMucGFyZW50ICYmIHRoaXMubW92ZUNoaWxkcmVuKHRoaXMucGFyZW50LCB0aGlzLm5leHQgfHwgdm9pZCAwKSwgdGhpcy5yZW1vdmUoKTtcbiAgfVxuICB1cGRhdGUobXV0YXRpb25zLCBfY29udGV4dCkge1xuICAgIGNvbnN0IGFkZGVkTm9kZXMgPSBbXSwgcmVtb3ZlZE5vZGVzID0gW107XG4gICAgbXV0YXRpb25zLmZvckVhY2goKG11dGF0aW9uKSA9PiB7XG4gICAgICBtdXRhdGlvbi50YXJnZXQgPT09IHRoaXMuZG9tTm9kZSAmJiBtdXRhdGlvbi50eXBlID09PSBcImNoaWxkTGlzdFwiICYmIChhZGRlZE5vZGVzLnB1c2goLi4ubXV0YXRpb24uYWRkZWROb2RlcyksIHJlbW92ZWROb2Rlcy5wdXNoKC4uLm11dGF0aW9uLnJlbW92ZWROb2RlcykpO1xuICAgIH0pLCByZW1vdmVkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPSBudWxsICYmIC8vIEB0cy1leHBlY3QtZXJyb3IgRml4IG1lIGxhdGVyXG4gICAgICBub2RlLnRhZ05hbWUgIT09IFwiSUZSQU1FXCIgJiYgZG9jdW1lbnQuYm9keS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBibG90ID0gdGhpcy5zY3JvbGwuZmluZChub2RlKTtcbiAgICAgIGJsb3QgIT0gbnVsbCAmJiAoYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgPT0gbnVsbCB8fCBibG90LmRvbU5vZGUucGFyZW50Tm9kZSA9PT0gdGhpcy5kb21Ob2RlKSAmJiBibG90LmRldGFjaCgpO1xuICAgIH0pLCBhZGRlZE5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5wYXJlbnROb2RlID09PSB0aGlzLmRvbU5vZGUgJiYgbm9kZSAhPT0gdGhpcy51aU5vZGUpLnNvcnQoKGEsIGIpID0+IGEgPT09IGIgPyAwIDogYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HID8gMSA6IC0xKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICBsZXQgcmVmQmxvdCA9IG51bGw7XG4gICAgICBub2RlLm5leHRTaWJsaW5nICE9IG51bGwgJiYgKHJlZkJsb3QgPSB0aGlzLnNjcm9sbC5maW5kKG5vZGUubmV4dFNpYmxpbmcpKTtcbiAgICAgIGNvbnN0IGJsb3QgPSBtYWtlQXR0YWNoZWRCbG90KG5vZGUsIHRoaXMuc2Nyb2xsKTtcbiAgICAgIChibG90Lm5leHQgIT09IHJlZkJsb3QgfHwgYmxvdC5uZXh0ID09IG51bGwpICYmIChibG90LnBhcmVudCAhPSBudWxsICYmIGJsb3QucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpLCB0aGlzLmluc2VydEJlZm9yZShibG90LCByZWZCbG90IHx8IHZvaWQgMCkpO1xuICAgIH0pLCB0aGlzLmVuZm9yY2VBbGxvd2VkQ2hpbGRyZW4oKTtcbiAgfVxufTtcbl9QYXJlbnRCbG90LnVpQ2xhc3MgPSBcIlwiO1xubGV0IFBhcmVudEJsb3QgPSBfUGFyZW50QmxvdDtcbmNvbnN0IFBhcmVudEJsb3QkMSA9IFBhcmVudEJsb3Q7XG5mdW5jdGlvbiBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChjb25zdCBwcm9wIGluIG9iajEpXG4gICAgaWYgKG9iajFbcHJvcF0gIT09IG9iajJbcHJvcF0pXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmNvbnN0IF9JbmxpbmVCbG90ID0gY2xhc3MgX0lubGluZUJsb3QgZXh0ZW5kcyBQYXJlbnRCbG90JDEge1xuICBzdGF0aWMgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNyZWF0ZSh2YWx1ZSk7XG4gIH1cbiAgc3RhdGljIGZvcm1hdHMoZG9tTm9kZSwgc2Nyb2xsKSB7XG4gICAgY29uc3QgbWF0Y2gyID0gc2Nyb2xsLnF1ZXJ5KF9JbmxpbmVCbG90LmJsb3ROYW1lKTtcbiAgICBpZiAoIShtYXRjaDIgIT0gbnVsbCAmJiBkb21Ob2RlLnRhZ05hbWUgPT09IG1hdGNoMi50YWdOYW1lKSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhZ05hbWUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSlcbiAgICAgICAgcmV0dXJuIGRvbU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICBzdXBlcihzY3JvbGwsIGRvbU5vZGUpLCB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRvclN0b3JlJDEodGhpcy5kb21Ob2RlKTtcbiAgfVxuICBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmICF2YWx1ZSlcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBfSW5saW5lQmxvdCB8fCAoY2hpbGQgPSBjaGlsZC53cmFwKF9JbmxpbmVCbG90LmJsb3ROYW1lLCAhMCkpLCB0aGlzLmF0dHJpYnV0ZXMuY29weShjaGlsZCk7XG4gICAgICB9KSwgdGhpcy51bndyYXAoKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuc2Nyb2xsLnF1ZXJ5KG5hbWUsIFNjb3BlLklOTElORSk7XG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZvcm1hdCBpbnN0YW5jZW9mIEF0dHJpYnV0b3IgPyB0aGlzLmF0dHJpYnV0ZXMuYXR0cmlidXRlKGZvcm1hdCwgdmFsdWUpIDogdmFsdWUgJiYgKG5hbWUgIT09IHRoaXMuc3RhdGljcy5ibG90TmFtZSB8fCB0aGlzLmZvcm1hdHMoKVtuYW1lXSAhPT0gdmFsdWUpICYmIHRoaXMucmVwbGFjZVdpdGgobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICBmb3JtYXRzKCkge1xuICAgIGNvbnN0IGZvcm1hdHMgPSB0aGlzLmF0dHJpYnV0ZXMudmFsdWVzKCksIGZvcm1hdCA9IHRoaXMuc3RhdGljcy5mb3JtYXRzKHRoaXMuZG9tTm9kZSwgdGhpcy5zY3JvbGwpO1xuICAgIHJldHVybiBmb3JtYXQgIT0gbnVsbCAmJiAoZm9ybWF0c1t0aGlzLnN0YXRpY3MuYmxvdE5hbWVdID0gZm9ybWF0KSwgZm9ybWF0cztcbiAgfVxuICBmb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuZm9ybWF0cygpW25hbWVdICE9IG51bGwgfHwgdGhpcy5zY3JvbGwucXVlcnkobmFtZSwgU2NvcGUuQVRUUklCVVRFKSA/IHRoaXMuaXNvbGF0ZShpbmRleCwgbGVuZ3RoKS5mb3JtYXQobmFtZSwgdmFsdWUpIDogc3VwZXIuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICB9XG4gIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICBzdXBlci5vcHRpbWl6ZShjb250ZXh0KTtcbiAgICBjb25zdCBmb3JtYXRzID0gdGhpcy5mb3JtYXRzKCk7XG4gICAgaWYgKE9iamVjdC5rZXlzKGZvcm1hdHMpLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLnVud3JhcCgpO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHQ7XG4gICAgbmV4dCBpbnN0YW5jZW9mIF9JbmxpbmVCbG90ICYmIG5leHQucHJldiA9PT0gdGhpcyAmJiBpc0VxdWFsKGZvcm1hdHMsIG5leHQuZm9ybWF0cygpKSAmJiAobmV4dC5tb3ZlQ2hpbGRyZW4odGhpcyksIG5leHQucmVtb3ZlKCkpO1xuICB9XG4gIHJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdXBlci5yZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5jb3B5KHJlcGxhY2VtZW50KSwgcmVwbGFjZW1lbnQ7XG4gIH1cbiAgdXBkYXRlKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgIHN1cGVyLnVwZGF0ZShtdXRhdGlvbnMsIGNvbnRleHQpLCBtdXRhdGlvbnMuc29tZShcbiAgICAgIChtdXRhdGlvbikgPT4gbXV0YXRpb24udGFyZ2V0ID09PSB0aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCJcbiAgICApICYmIHRoaXMuYXR0cmlidXRlcy5idWlsZCgpO1xuICB9XG4gIHdyYXAobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gc3VwZXIud3JhcChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHdyYXBwZXIgaW5zdGFuY2VvZiBfSW5saW5lQmxvdCAmJiB0aGlzLmF0dHJpYnV0ZXMubW92ZSh3cmFwcGVyKSwgd3JhcHBlcjtcbiAgfVxufTtcbl9JbmxpbmVCbG90LmFsbG93ZWRDaGlsZHJlbiA9IFtfSW5saW5lQmxvdCwgTGVhZkJsb3QkMV0sIF9JbmxpbmVCbG90LmJsb3ROYW1lID0gXCJpbmxpbmVcIiwgX0lubGluZUJsb3Quc2NvcGUgPSBTY29wZS5JTkxJTkVfQkxPVCwgX0lubGluZUJsb3QudGFnTmFtZSA9IFwiU1BBTlwiO1xubGV0IElubGluZUJsb3QgPSBfSW5saW5lQmxvdDtcbmNvbnN0IElubGluZUJsb3QkMSA9IElubGluZUJsb3QsIF9CbG9ja0Jsb3QgPSBjbGFzcyBfQmxvY2tCbG90IGV4dGVuZHMgUGFyZW50QmxvdCQxIHtcbiAgc3RhdGljIGNyZWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlci5jcmVhdGUodmFsdWUpO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRzKGRvbU5vZGUsIHNjcm9sbCkge1xuICAgIGNvbnN0IG1hdGNoMiA9IHNjcm9sbC5xdWVyeShfQmxvY2tCbG90LmJsb3ROYW1lKTtcbiAgICBpZiAoIShtYXRjaDIgIT0gbnVsbCAmJiBkb21Ob2RlLnRhZ05hbWUgPT09IG1hdGNoMi50YWdOYW1lKSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhZ05hbWUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy50YWdOYW1lKSlcbiAgICAgICAgcmV0dXJuIGRvbU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdHJ1Y3RvcihzY3JvbGwsIGRvbU5vZGUpIHtcbiAgICBzdXBlcihzY3JvbGwsIGRvbU5vZGUpLCB0aGlzLmF0dHJpYnV0ZXMgPSBuZXcgQXR0cmlidXRvclN0b3JlJDEodGhpcy5kb21Ob2RlKTtcbiAgfVxuICBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLnNjcm9sbC5xdWVyeShuYW1lLCBTY29wZS5CTE9DSyk7XG4gICAgZm9ybWF0ICE9IG51bGwgJiYgKGZvcm1hdCBpbnN0YW5jZW9mIEF0dHJpYnV0b3IgPyB0aGlzLmF0dHJpYnV0ZXMuYXR0cmlidXRlKGZvcm1hdCwgdmFsdWUpIDogbmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lICYmICF2YWx1ZSA/IHRoaXMucmVwbGFjZVdpdGgoX0Jsb2NrQmxvdC5ibG90TmFtZSkgOiB2YWx1ZSAmJiAobmFtZSAhPT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lIHx8IHRoaXMuZm9ybWF0cygpW25hbWVdICE9PSB2YWx1ZSkgJiYgdGhpcy5yZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSkpO1xuICB9XG4gIGZvcm1hdHMoKSB7XG4gICAgY29uc3QgZm9ybWF0cyA9IHRoaXMuYXR0cmlidXRlcy52YWx1ZXMoKSwgZm9ybWF0ID0gdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlLCB0aGlzLnNjcm9sbCk7XG4gICAgcmV0dXJuIGZvcm1hdCAhPSBudWxsICYmIChmb3JtYXRzW3RoaXMuc3RhdGljcy5ibG90TmFtZV0gPSBmb3JtYXQpLCBmb3JtYXRzO1xuICB9XG4gIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5zY3JvbGwucXVlcnkobmFtZSwgU2NvcGUuQkxPQ0spICE9IG51bGwgPyB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSkgOiBzdXBlci5mb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICBpZiAoZGVmID09IG51bGwgfHwgdGhpcy5zY3JvbGwucXVlcnkodmFsdWUsIFNjb3BlLklOTElORSkgIT0gbnVsbClcbiAgICAgIHN1cGVyLmluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGFmdGVyID0gdGhpcy5zcGxpdChpbmRleCk7XG4gICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBibG90ID0gdGhpcy5zY3JvbGwuY3JlYXRlKHZhbHVlLCBkZWYpO1xuICAgICAgICBhZnRlci5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJsb3QsIGFmdGVyKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbXB0IHRvIGluc2VydEF0IGFmdGVyIGJsb2NrIGJvdW5kYXJpZXNcIik7XG4gICAgfVxuICB9XG4gIHJlcGxhY2VXaXRoKG5hbWUsIHZhbHVlKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdXBlci5yZXBsYWNlV2l0aChuYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5jb3B5KHJlcGxhY2VtZW50KSwgcmVwbGFjZW1lbnQ7XG4gIH1cbiAgdXBkYXRlKG11dGF0aW9ucywgY29udGV4dCkge1xuICAgIHN1cGVyLnVwZGF0ZShtdXRhdGlvbnMsIGNvbnRleHQpLCBtdXRhdGlvbnMuc29tZShcbiAgICAgIChtdXRhdGlvbikgPT4gbXV0YXRpb24udGFyZ2V0ID09PSB0aGlzLmRvbU5vZGUgJiYgbXV0YXRpb24udHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCJcbiAgICApICYmIHRoaXMuYXR0cmlidXRlcy5idWlsZCgpO1xuICB9XG59O1xuX0Jsb2NrQmxvdC5ibG90TmFtZSA9IFwiYmxvY2tcIiwgX0Jsb2NrQmxvdC5zY29wZSA9IFNjb3BlLkJMT0NLX0JMT1QsIF9CbG9ja0Jsb3QudGFnTmFtZSA9IFwiUFwiLCBfQmxvY2tCbG90LmFsbG93ZWRDaGlsZHJlbiA9IFtcbiAgSW5saW5lQmxvdCQxLFxuICBfQmxvY2tCbG90LFxuICBMZWFmQmxvdCQxXG5dO1xubGV0IEJsb2NrQmxvdCA9IF9CbG9ja0Jsb3Q7XG5jb25zdCBCbG9ja0Jsb3QkMSA9IEJsb2NrQmxvdCwgX0NvbnRhaW5lckJsb3QgPSBjbGFzcyBfQ29udGFpbmVyQmxvdCBleHRlbmRzIFBhcmVudEJsb3QkMSB7XG4gIGNoZWNrTWVyZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dCAhPT0gbnVsbCAmJiB0aGlzLm5leHQuc3RhdGljcy5ibG90TmFtZSA9PT0gdGhpcy5zdGF0aWNzLmJsb3ROYW1lO1xuICB9XG4gIGRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpIHtcbiAgICBzdXBlci5kZWxldGVBdChpbmRleCwgbGVuZ3RoKSwgdGhpcy5lbmZvcmNlQWxsb3dlZENoaWxkcmVuKCk7XG4gIH1cbiAgZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICBzdXBlci5mb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSksIHRoaXMuZW5mb3JjZUFsbG93ZWRDaGlsZHJlbigpO1xuICB9XG4gIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgc3VwZXIuaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpLCB0aGlzLmVuZm9yY2VBbGxvd2VkQ2hpbGRyZW4oKTtcbiAgfVxuICBvcHRpbWl6ZShjb250ZXh0KSB7XG4gICAgc3VwZXIub3B0aW1pemUoY29udGV4dCksIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiB0aGlzLm5leHQgIT0gbnVsbCAmJiB0aGlzLmNoZWNrTWVyZ2UoKSAmJiAodGhpcy5uZXh0Lm1vdmVDaGlsZHJlbih0aGlzKSwgdGhpcy5uZXh0LnJlbW92ZSgpKTtcbiAgfVxufTtcbl9Db250YWluZXJCbG90LmJsb3ROYW1lID0gXCJjb250YWluZXJcIiwgX0NvbnRhaW5lckJsb3Quc2NvcGUgPSBTY29wZS5CTE9DS19CTE9UO1xubGV0IENvbnRhaW5lckJsb3QgPSBfQ29udGFpbmVyQmxvdDtcbmNvbnN0IENvbnRhaW5lckJsb3QkMSA9IENvbnRhaW5lckJsb3Q7XG5jbGFzcyBFbWJlZEJsb3QgZXh0ZW5kcyBMZWFmQmxvdCQxIHtcbiAgc3RhdGljIGZvcm1hdHMoX2RvbU5vZGUsIF9zY3JvbGwpIHtcbiAgfVxuICBmb3JtYXQobmFtZSwgdmFsdWUpIHtcbiAgICBzdXBlci5mb3JtYXRBdCgwLCB0aGlzLmxlbmd0aCgpLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpIHtcbiAgICBpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkgPyB0aGlzLmZvcm1hdChuYW1lLCB2YWx1ZSkgOiBzdXBlci5mb3JtYXRBdChpbmRleCwgbGVuZ3RoLCBuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgZm9ybWF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWNzLmZvcm1hdHModGhpcy5kb21Ob2RlLCB0aGlzLnNjcm9sbCk7XG4gIH1cbn1cbmNvbnN0IEVtYmVkQmxvdCQxID0gRW1iZWRCbG90LCBPQlNFUlZFUl9DT05GSUcgPSB7XG4gIGF0dHJpYnV0ZXM6ICEwLFxuICBjaGFyYWN0ZXJEYXRhOiAhMCxcbiAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiAhMCxcbiAgY2hpbGRMaXN0OiAhMCxcbiAgc3VidHJlZTogITBcbn0sIE1BWF9PUFRJTUlaRV9JVEVSQVRJT05TID0gMTAwLCBfU2Nyb2xsQmxvdCA9IGNsYXNzIF9TY3JvbGxCbG90IGV4dGVuZHMgUGFyZW50QmxvdCQxIHtcbiAgY29uc3RydWN0b3IocmVnaXN0cnksIG5vZGUpIHtcbiAgICBzdXBlcihudWxsLCBub2RlKSwgdGhpcy5yZWdpc3RyeSA9IHJlZ2lzdHJ5LCB0aGlzLnNjcm9sbCA9IHRoaXMsIHRoaXMuYnVpbGQoKSwgdGhpcy5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlKG11dGF0aW9ucyk7XG4gICAgfSksIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbU5vZGUsIE9CU0VSVkVSX0NPTkZJRyksIHRoaXMuYXR0YWNoKCk7XG4gIH1cbiAgY3JlYXRlKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmNyZWF0ZSh0aGlzLCBpbnB1dCwgdmFsdWUpO1xuICB9XG4gIGZpbmQobm9kZSwgYnViYmxlID0gITEpIHtcbiAgICBjb25zdCBibG90ID0gdGhpcy5yZWdpc3RyeS5maW5kKG5vZGUsIGJ1YmJsZSk7XG4gICAgcmV0dXJuIGJsb3QgPyBibG90LnNjcm9sbCA9PT0gdGhpcyA/IGJsb3QgOiBidWJibGUgPyB0aGlzLmZpbmQoYmxvdC5zY3JvbGwuZG9tTm9kZS5wYXJlbnROb2RlLCAhMCkgOiBudWxsIDogbnVsbDtcbiAgfVxuICBxdWVyeShxdWVyeSwgc2NvcGUgPSBTY29wZS5BTlkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5xdWVyeShxdWVyeSwgc2NvcGUpO1xuICB9XG4gIHJlZ2lzdGVyKC4uLmRlZmluaXRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0cnkucmVnaXN0ZXIoLi4uZGVmaW5pdGlvbnMpO1xuICB9XG4gIGJ1aWxkKCkge1xuICAgIHRoaXMuc2Nyb2xsICE9IG51bGwgJiYgc3VwZXIuYnVpbGQoKTtcbiAgfVxuICBkZXRhY2goKSB7XG4gICAgc3VwZXIuZGV0YWNoKCksIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpIHtcbiAgICB0aGlzLnVwZGF0ZSgpLCBpbmRleCA9PT0gMCAmJiBsZW5ndGggPT09IHRoaXMubGVuZ3RoKCkgPyB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICB9KSA6IHN1cGVyLmRlbGV0ZUF0KGluZGV4LCBsZW5ndGgpO1xuICB9XG4gIGZvcm1hdEF0KGluZGV4LCBsZW5ndGgsIG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy51cGRhdGUoKSwgc3VwZXIuZm9ybWF0QXQoaW5kZXgsIGxlbmd0aCwgbmFtZSwgdmFsdWUpO1xuICB9XG4gIGluc2VydEF0KGluZGV4LCB2YWx1ZSwgZGVmKSB7XG4gICAgdGhpcy51cGRhdGUoKSwgc3VwZXIuaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpO1xuICB9XG4gIG9wdGltaXplKG11dGF0aW9ucyA9IFtdLCBjb250ZXh0ID0ge30pIHtcbiAgICBzdXBlci5vcHRpbWl6ZShjb250ZXh0KTtcbiAgICBjb25zdCBtdXRhdGlvbnNNYXAgPSBjb250ZXh0Lm11dGF0aW9uc01hcCB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBsZXQgcmVjb3JkcyA9IEFycmF5LmZyb20odGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICBmb3IgKDsgcmVjb3Jkcy5sZW5ndGggPiAwOyApXG4gICAgICBtdXRhdGlvbnMucHVzaChyZWNvcmRzLnBvcCgpKTtcbiAgICBjb25zdCBtYXJrID0gKGJsb3QsIG1hcmtQYXJlbnQgPSAhMCkgPT4ge1xuICAgICAgYmxvdCA9PSBudWxsIHx8IGJsb3QgPT09IHRoaXMgfHwgYmxvdC5kb21Ob2RlLnBhcmVudE5vZGUgIT0gbnVsbCAmJiAobXV0YXRpb25zTWFwLmhhcyhibG90LmRvbU5vZGUpIHx8IG11dGF0aW9uc01hcC5zZXQoYmxvdC5kb21Ob2RlLCBbXSksIG1hcmtQYXJlbnQgJiYgbWFyayhibG90LnBhcmVudCkpO1xuICAgIH0sIG9wdGltaXplID0gKGJsb3QpID0+IHtcbiAgICAgIG11dGF0aW9uc01hcC5oYXMoYmxvdC5kb21Ob2RlKSAmJiAoYmxvdCBpbnN0YW5jZW9mIFBhcmVudEJsb3QkMSAmJiBibG90LmNoaWxkcmVuLmZvckVhY2gob3B0aW1pemUpLCBtdXRhdGlvbnNNYXAuZGVsZXRlKGJsb3QuZG9tTm9kZSksIGJsb3Qub3B0aW1pemUoY29udGV4dCkpO1xuICAgIH07XG4gICAgbGV0IHJlbWFpbmluZyA9IG11dGF0aW9ucztcbiAgICBmb3IgKGxldCBpID0gMDsgcmVtYWluaW5nLmxlbmd0aCA+IDA7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgPj0gTUFYX09QVElNSVpFX0lURVJBVElPTlMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltQYXJjaG1lbnRdIE1heGltdW0gb3B0aW1pemUgaXRlcmF0aW9ucyByZWFjaGVkXCIpO1xuICAgICAgZm9yIChyZW1haW5pbmcuZm9yRWFjaCgobXV0YXRpb24pID0+IHtcbiAgICAgICAgY29uc3QgYmxvdCA9IHRoaXMuZmluZChtdXRhdGlvbi50YXJnZXQsICEwKTtcbiAgICAgICAgYmxvdCAhPSBudWxsICYmIChibG90LmRvbU5vZGUgPT09IG11dGF0aW9uLnRhcmdldCAmJiAobXV0YXRpb24udHlwZSA9PT0gXCJjaGlsZExpc3RcIiA/IChtYXJrKHRoaXMuZmluZChtdXRhdGlvbi5wcmV2aW91c1NpYmxpbmcsICExKSksIEFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcykuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5maW5kKG5vZGUsICExKTtcbiAgICAgICAgICBtYXJrKGNoaWxkLCAhMSksIGNoaWxkIGluc3RhbmNlb2YgUGFyZW50QmxvdCQxICYmIGNoaWxkLmNoaWxkcmVuLmZvckVhY2goKGdyYW5kQ2hpbGQpID0+IHtcbiAgICAgICAgICAgIG1hcmsoZ3JhbmRDaGlsZCwgITEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkgOiBtdXRhdGlvbi50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJiBtYXJrKGJsb3QucHJldikpLCBtYXJrKGJsb3QpKTtcbiAgICAgIH0pLCB0aGlzLmNoaWxkcmVuLmZvckVhY2gob3B0aW1pemUpLCByZW1haW5pbmcgPSBBcnJheS5mcm9tKHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSksIHJlY29yZHMgPSByZW1haW5pbmcuc2xpY2UoKTsgcmVjb3Jkcy5sZW5ndGggPiAwOyApXG4gICAgICAgIG11dGF0aW9ucy5wdXNoKHJlY29yZHMucG9wKCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUobXV0YXRpb25zLCBjb250ZXh0ID0ge30pIHtcbiAgICBtdXRhdGlvbnMgPSBtdXRhdGlvbnMgfHwgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgIGNvbnN0IG11dGF0aW9uc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIG11dGF0aW9ucy5tYXAoKG11dGF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBibG90ID0gdGhpcy5maW5kKG11dGF0aW9uLnRhcmdldCwgITApO1xuICAgICAgcmV0dXJuIGJsb3QgPT0gbnVsbCA/IG51bGwgOiBtdXRhdGlvbnNNYXAuaGFzKGJsb3QuZG9tTm9kZSkgPyAobXV0YXRpb25zTWFwLmdldChibG90LmRvbU5vZGUpLnB1c2gobXV0YXRpb24pLCBudWxsKSA6IChtdXRhdGlvbnNNYXAuc2V0KGJsb3QuZG9tTm9kZSwgW211dGF0aW9uXSksIGJsb3QpO1xuICAgIH0pLmZvckVhY2goKGJsb3QpID0+IHtcbiAgICAgIGJsb3QgIT0gbnVsbCAmJiBibG90ICE9PSB0aGlzICYmIG11dGF0aW9uc01hcC5oYXMoYmxvdC5kb21Ob2RlKSAmJiBibG90LnVwZGF0ZShtdXRhdGlvbnNNYXAuZ2V0KGJsb3QuZG9tTm9kZSkgfHwgW10sIGNvbnRleHQpO1xuICAgIH0pLCBjb250ZXh0Lm11dGF0aW9uc01hcCA9IG11dGF0aW9uc01hcCwgbXV0YXRpb25zTWFwLmhhcyh0aGlzLmRvbU5vZGUpICYmIHN1cGVyLnVwZGF0ZShtdXRhdGlvbnNNYXAuZ2V0KHRoaXMuZG9tTm9kZSksIGNvbnRleHQpLCB0aGlzLm9wdGltaXplKG11dGF0aW9ucywgY29udGV4dCk7XG4gIH1cbn07XG5fU2Nyb2xsQmxvdC5ibG90TmFtZSA9IFwic2Nyb2xsXCIsIF9TY3JvbGxCbG90LmRlZmF1bHRDaGlsZCA9IEJsb2NrQmxvdCQxLCBfU2Nyb2xsQmxvdC5hbGxvd2VkQ2hpbGRyZW4gPSBbQmxvY2tCbG90JDEsIENvbnRhaW5lckJsb3QkMV0sIF9TY3JvbGxCbG90LnNjb3BlID0gU2NvcGUuQkxPQ0tfQkxPVCwgX1Njcm9sbEJsb3QudGFnTmFtZSA9IFwiRElWXCI7XG5sZXQgU2Nyb2xsQmxvdCA9IF9TY3JvbGxCbG90O1xuY29uc3QgU2Nyb2xsQmxvdCQxID0gU2Nyb2xsQmxvdCwgX1RleHRCbG90ID0gY2xhc3MgX1RleHRCbG90IGV4dGVuZHMgTGVhZkJsb3QkMSB7XG4gIHN0YXRpYyBjcmVhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICB9XG4gIHN0YXRpYyB2YWx1ZShkb21Ob2RlKSB7XG4gICAgcmV0dXJuIGRvbU5vZGUuZGF0YTtcbiAgfVxuICBjb25zdHJ1Y3RvcihzY3JvbGwsIG5vZGUpIHtcbiAgICBzdXBlcihzY3JvbGwsIG5vZGUpLCB0aGlzLnRleHQgPSB0aGlzLnN0YXRpY3MudmFsdWUodGhpcy5kb21Ob2RlKTtcbiAgfVxuICBkZWxldGVBdChpbmRleCwgbGVuZ3RoKSB7XG4gICAgdGhpcy5kb21Ob2RlLmRhdGEgPSB0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaW5kZXgpICsgdGhpcy50ZXh0LnNsaWNlKGluZGV4ICsgbGVuZ3RoKTtcbiAgfVxuICBpbmRleChub2RlLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5kb21Ob2RlID09PSBub2RlID8gb2Zmc2V0IDogLTE7XG4gIH1cbiAgaW5zZXJ0QXQoaW5kZXgsIHZhbHVlLCBkZWYpIHtcbiAgICBkZWYgPT0gbnVsbCA/ICh0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUgKyB0aGlzLnRleHQuc2xpY2UoaW5kZXgpLCB0aGlzLmRvbU5vZGUuZGF0YSA9IHRoaXMudGV4dCkgOiBzdXBlci5pbnNlcnRBdChpbmRleCwgdmFsdWUsIGRlZik7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQubGVuZ3RoO1xuICB9XG4gIG9wdGltaXplKGNvbnRleHQpIHtcbiAgICBzdXBlci5vcHRpbWl6ZShjb250ZXh0KSwgdGhpcy50ZXh0ID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSksIHRoaXMudGV4dC5sZW5ndGggPT09IDAgPyB0aGlzLnJlbW92ZSgpIDogdGhpcy5uZXh0IGluc3RhbmNlb2YgX1RleHRCbG90ICYmIHRoaXMubmV4dC5wcmV2ID09PSB0aGlzICYmICh0aGlzLmluc2VydEF0KHRoaXMubGVuZ3RoKCksIHRoaXMubmV4dC52YWx1ZSgpKSwgdGhpcy5uZXh0LnJlbW92ZSgpKTtcbiAgfVxuICBwb3NpdGlvbihpbmRleCwgX2luY2x1c2l2ZSA9ICExKSB7XG4gICAgcmV0dXJuIFt0aGlzLmRvbU5vZGUsIGluZGV4XTtcbiAgfVxuICBzcGxpdChpbmRleCwgZm9yY2UgPSAhMSkge1xuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMubGVuZ3RoKCkpXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQ7XG4gICAgfVxuICAgIGNvbnN0IGFmdGVyID0gdGhpcy5zY3JvbGwuY3JlYXRlKHRoaXMuZG9tTm9kZS5zcGxpdFRleHQoaW5kZXgpKTtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGFmdGVyLCB0aGlzLm5leHQgfHwgdm9pZCAwKSwgdGhpcy50ZXh0ID0gdGhpcy5zdGF0aWNzLnZhbHVlKHRoaXMuZG9tTm9kZSksIGFmdGVyO1xuICB9XG4gIHVwZGF0ZShtdXRhdGlvbnMsIF9jb250ZXh0KSB7XG4gICAgbXV0YXRpb25zLnNvbWUoKG11dGF0aW9uKSA9PiBtdXRhdGlvbi50eXBlID09PSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50YXJnZXQgPT09IHRoaXMuZG9tTm9kZSkgJiYgKHRoaXMudGV4dCA9IHRoaXMuc3RhdGljcy52YWx1ZSh0aGlzLmRvbU5vZGUpKTtcbiAgfVxuICB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG59O1xuX1RleHRCbG90LmJsb3ROYW1lID0gXCJ0ZXh0XCIsIF9UZXh0QmxvdC5zY29wZSA9IFNjb3BlLklOTElORV9CTE9UO1xubGV0IFRleHRCbG90ID0gX1RleHRCbG90O1xuY29uc3QgVGV4dEJsb3QkMSA9IFRleHRCbG90O1xuZXhwb3J0IHtcbiAgQXR0cmlidXRvcixcbiAgQXR0cmlidXRvclN0b3JlJDEgYXMgQXR0cmlidXRvclN0b3JlLFxuICBCbG9ja0Jsb3QkMSBhcyBCbG9ja0Jsb3QsXG4gIENsYXNzQXR0cmlidXRvciQxIGFzIENsYXNzQXR0cmlidXRvcixcbiAgQ29udGFpbmVyQmxvdCQxIGFzIENvbnRhaW5lckJsb3QsXG4gIEVtYmVkQmxvdCQxIGFzIEVtYmVkQmxvdCxcbiAgSW5saW5lQmxvdCQxIGFzIElubGluZUJsb3QsXG4gIExlYWZCbG90JDEgYXMgTGVhZkJsb3QsXG4gIFBhcmVudEJsb3QkMSBhcyBQYXJlbnRCbG90LFxuICBSZWdpc3RyeSxcbiAgU2NvcGUsXG4gIFNjcm9sbEJsb3QkMSBhcyBTY3JvbGxCbG90LFxuICBTdHlsZUF0dHJpYnV0b3IkMSBhcyBTdHlsZUF0dHJpYnV0b3IsXG4gIFRleHRCbG90JDEgYXMgVGV4dEJsb3Rcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJjaG1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/parchment@3.0.0/node_modules/parchment/dist/parchment.js\n");

/***/ })

};
;